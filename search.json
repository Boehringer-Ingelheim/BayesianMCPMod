[{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Comparison of Bayesian MCPMod and MCPMod","text":"vignette demonstrates application BayesianMCPMod package sample size calculations comparison MCPModPack package. Bayesian MCPMod set way mimics results (operating characteristics) frequentist MCPMod vague priors. characteristic illustrated following sections focusing trial planning. following dose-finding scenario considered compare Bayesian MCPMod MCPModPack success probabilities: Four dose levels plus placebo (0 mg, 1 mg, 2 mg, 4 mg, 8 mg) Total sample size N = 200 equal allocation ratio dose group, .e., 40 per group Standard deviation 0.4 every dose group Alpha level 5% Simulations performed 10000 runs. Given number simulations applying law large numbers, difference success probabilities range 1% - 3%. following figure shows considered candidate models.","code":"doses_sim     <- c(0, 1, 2, 4, 8)  n_sample      <- c(40, 40, 40, 40, 40) sd_sim        <- 0.4  max_dose      <- max(doses_sim)     plc_eff_guess <- 0      alpha         <- 0.05 set.seed(7015) n_sim <- 10000  plan(multisession) registerDoFuture() emax_guess     <- guesst(d = doses_sim[2], p = 0.6, \"emax\")  exp_guess      <- guesst(d = doses_sim[2], p = 0.05, model = \"exponential\", Maxd = max_dose) logit_guess    <- guesst(d = c(doses_sim[2], doses_sim[3]), p = c(0.1, 0.9), \"logistic\", Maxd = max_dose)  sig_emax_guess <- guesst(d = c(doses_sim[2], doses_sim[3]), p = c(0.15, 0.75), model = \"sigEmax\")   plot(Mods(linear      = NULL,           exponential = exp_guess,           emax        = emax_guess,           logistic    = logit_guess,           sigEmax     = sig_emax_guess,           doses       = doses_sim,           placEff     = plc_eff_guess,           direction   = \"increasing\"),      main = \"Candidate Models\")"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"varying-the-expected-effect-for-maximum-dose","dir":"Articles","previous_headings":"","what":"Varying the Expected Effect for Maximum Dose","title":"Comparison of Bayesian MCPMod and MCPMod","text":"following expected effects studied: Expected effect maximum dose 0.0001, 0.05, 0.1, 0.2, 0.3, 0.5 value 0.0001 chosen instead 0 due technical reasons. case mimic null scenario (expect success probability close alpha level). following plot shows differences results obtained MCPModPack BayesianMCPMod. results BayesianMCPMod shown horizontal lines differences results MCPModPack presented vertical lines. results close one another, vertical lines barely visible. colours indicate different assumed true dose-response models, basis simulating data.  expected, operating characteristics BayesianMCPMod vague priors match operating characteristics frequentist MCPMod. Numerical results shown two tables .","code":"exp_eff <- c(0.0001, 0.05, 0.1, 0.2, 0.3, 0.5) # Simulation parameters sim_parameters <- list(n            = n_sample,                        doses        = doses_sim,                        dropout_rate = 0.0,                        go_threshold = 0.1,                        nsims        = n_sim)  # Candidate dose - response models models_MCPModPack = list(linear      = NA,                          exponential = exp_guess,                          emax        = emax_guess,                          logistic    = logit_guess,                          sigemax     = sig_emax_guess)  # Assumed dose - response models (models will be added in loop) sim_models_part <- list(max_effect     = exp_eff,                         sd             = rep(sd_sim, length(doses_sim)),                         placebo_effect = plc_eff_guess)  # Parallelization across assumed dose - response models powers_MCPModPack_eff <- foreach(   k = seq_along(models_MCPModPack),   .combine = cbind,    .options.future = list(seed = TRUE)) %dofuture% {          sim_model_k <- c(models_MCPModPack[k], sim_models_part)          MCPModSimulation(endpoint_type   = \"Normal\",                      models          = models_MCPModPack,                      alpha           = alpha,                      direction       = \"increasing\",                      model_selection = \"aveAIC\",                      Delta           = 0.1,                      sim_models      = sim_model_k,                      sim_parameters  = sim_parameters)$sim_results$power      }  # Post-processing result for printing colnames(powers_MCPModPack_eff) <- names(models_MCPModPack) results_MCPModPack_eff <- cbind(max_eff = round(exp_eff, digits = 2),                                 powers_MCPModPack_eff) %>%   data.frame() %>%   rename(sigEmax = sigemax) %>%   mutate(average = rowMeans(select(., linear:sigEmax))) # Vague prior specification prior_list_vague <- rep(list(RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1),                                             sigma = sd_sim, param = \"mn\")),                         times = length(doses_sim)) names(prior_list_vague) <- c(\"Ctrl\", \"DG_1\", \"DG_2\", \"DG_3\", \"DG_4\")  # Parallelization across the expected effects for maximum dose success_rates_BayesianMCPMod_eff <- foreach(   k               = seq_along(exp_eff),   .combine        = rbind,    .options.future = list(seed = TRUE)) %dofuture% {          exp_eff_k <- exp_eff[k]          models_BayesianMCPMod <- Mods(linear      = NULL,                                   exponential = exp_guess,                                   emax        = emax_guess,                                   logistic    = logit_guess,                                   sigEmax     = sig_emax_guess,                                   doses       = doses_sim,                                   placEff     = plc_eff_guess,                                   maxEff      = exp_eff_k,                                   direction   = \"increasing\")             # Optimal contrasts     contr <- getContr(mods         = models_BayesianMCPMod,                       dose_levels  = doses_sim,                       prior_list   = prior_list_vague,                       dose_weights = rep(1, length(doses_sim)))        # Perform Simulations     sim_result <- assessDesign(n_patients     = n_sample,                                mods           = models_BayesianMCPMod,                                prior_list     = prior_list_vague,                                sd             = sd_sim,                                n_sim          = n_sim,                                alpha_crit_val = alpha,                                contr          = contr)          c(sapply(sim_result, attr, \"successRate\"),       average = attr(sim_result, \"avgSuccessRate\"))      }  # Post-processing result for printing rownames(success_rates_BayesianMCPMod_eff) <- NULL results_BayesianMCPMod_eff <- data.frame(cbind(max_eff = round(exp_eff, digits = 2),                                            success_rates_BayesianMCPMod_eff)) ## pre-processing the data df_plot_eff <- rbind(results_MCPModPack_eff %>%                       mutate(package_name = \"MCPModPack\"),                      results_BayesianMCPMod_eff %>%                       mutate(package_name = \"BayesianMCPMod\")) %>%   pivot_longer(cols      = names(results_BayesianMCPMod_eff)[-1],                names_to  = \"model_shape\",                values_to = \"success_rate\") %>%   filter(model_shape != \"average\") %>%   spread(key = package_name, value = success_rate)  %>%   mutate(model_shape = as.factor(model_shape),          max_eff     = as.factor(max_eff)) %>%   group_by(max_eff) %>%   mutate(offset = 0.1 * (seq_along(model_shape) - ceiling(length(model_shape) / 2)))  # Plot with short horizontal dashes for each model_shape ggplot(df_plot_eff, aes(x = as.numeric(max_eff) + offset, y = BayesianMCPMod, color = model_shape)) +   geom_segment(aes(x = as.numeric(max_eff) + offset - 0.05, xend = as.numeric(max_eff) + offset + 0.05,                    y = BayesianMCPMod, yend = BayesianMCPMod)) +   geom_segment(aes(xend = as.numeric(max_eff) + offset, yend = MCPModPack)) +   scale_x_continuous(breaks = unique(as.numeric(df_plot_eff$max_eff)), labels = levels(df_plot_eff$max_eff)) +   labs(title    = \"Comparing Power and Success Rate\",        subtitle = \"For Different Expected Effects for Maximum Dose\",        x        = \"Expected Effect for Maximum Dose\",        y        = \"Success Rate / Power\",        color    = \"Assumed True Model Shapes\",        linetype = \"Type\",        caption  = \"Horizontal lines represent the BayesianMCPMod success rates and vertical lines mark the distance to the MCPModPack power.\") +   theme_minimal() +    theme(legend.position = \"bottom\") ## Ignoring unknown labels: ## • linetype : \"Type\" kable(results_MCPModPack_eff) %>%   kable_classic() %>%     add_header_above(c(\"Power Values Across Different Expected Effects\" = 7),                      font_size = 15, bold = TRUE) %>%     add_header_above(c(\"MCPModPack\" = 7), font_size = 15, bold = TRUE) kable(results_BayesianMCPMod_eff) %>%   kable_classic(full_width = TRUE) %>%     add_header_above(c(\"Success Rates Across Different Expected Effects\" = 7),                      font_size = 15, bold = TRUE) %>%     add_header_above(c(\"BayesianMCPMod\" = 7), font_size = 15, bold = TRUE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"convergence-of-power-values","dir":"Articles","previous_headings":"","what":"Convergence of Power Values","title":"Comparison of Bayesian MCPMod and MCPMod","text":"following simulations, examine convergence power success rate values increasing number simulations. , expected maximum effect fixed 0.2. R package MCPModPack provides final power result given number simulations allow accessing intermediate power values. simulation repeated different values number simulations implementation MCPModPack. BayesianMCPMod implementation, one simulation run required access estimated success rate values different numbers simulations. figure shows convergence power success rate values increasing number simulations.  expected, differences within range 1% - 3%.","code":"exp_eff_fix <- 0.2 n_sim_vec <- seq(2, 10, 1)^4 # Updating the assumed dose - response models for the fixed expected effect (models will be added in loop) sim_models_part$max_effect <- exp_eff_fix  # Parallelization across assumed dose - response models & number of simulations ## Reversing the numbers speeds up parallelization in case there are not enough workers sim_grid <- expand.grid(names(models_MCPModPack), rev(n_sim_vec)) powers_MCPModPack_conv <- foreach(   k = seq_len(nrow(sim_grid)),   .combine = c,   .options.future = list(seed = TRUE)) %dofuture% {          sim_model_k <- c(models_MCPModPack[sim_grid[k, 1]], sim_models_part)          sim_params_k <- sim_parameters     sim_params_k$nsims <- sim_grid[k, 2]          MCPModSimulation(endpoint_type   = \"Normal\",                      models          = models_MCPModPack,                      alpha           = alpha,                      direction       = \"increasing\",                      model_selection = \"aveAIC\",                      Delta           = 0.1,                      sim_models      = sim_model_k,                      sim_parameters  = sim_params_k)$sim_results$power      }  #Post-processing results_MCPModPack_conv <- cbind(sim_grid, powers_MCPModPack_conv) %>%   arrange(desc(row_number())) %>%   rename(model_name   = Var1,          n_sim        = Var2,          success_rate = powers_MCPModPack_conv) %>%   mutate(model_name = if_else(model_name == \"sigemax\",                              \"sigEmax\", model_name)) %>%   mutate(package_name = \"MCPModPack\") # Model specifications with fixed expected effect models_BayesianMCPMod <- Mods(linear      = NULL,                               exponential = exp_guess,                               emax        = emax_guess,                               logistic    = logit_guess,                               sigEmax     = sig_emax_guess,                               doses       = doses_sim,                               placEff     = plc_eff_guess,                               maxEff      = exp_eff_fix,                               direction   = \"increasing\")         # Optimal contrasts contr <- getContr(mods         = models_BayesianMCPMod,                   dose_levels  = doses_sim,                   prior_list   = prior_list_vague,                   dose_weights = rep(1, length(doses_sim)))  # Perform Simulations sim_result <- assessDesign(n_patients     = n_sample,                            mods           = models_BayesianMCPMod,                            prior_list     = prior_list_vague,                            sd             = sd_sim,                            n_sim          = max(n_sim_vec),                            alpha_crit_val = alpha,                            contr          = contr)  # Getting success rates at different numbers of simulations results_BayesianMCPMod_conv <- sapply(sim_result, function (model_result) {      sapply(n_sim_vec, function (n_sim_x) {          success_rate_x <- mean(model_result[seq_len(n_sim_x), 1])        })    }) %>%   # Post-processing   as.data.frame %>%   mutate(n_sim = n_sim_vec) %>%   pivot_longer(cols = -n_sim,                names_to = \"model_name\",                values_to = \"success_rate\") %>%   mutate(package_name = \"BayesianMCPMod\") df_plot_conv <- inner_join(results_BayesianMCPMod_conv,                            results_MCPModPack_conv,                            by = c(\"model_name\", \"n_sim\")) %>%   mutate(success_rate_diff = success_rate.x - success_rate.y) %>%   select(model_name, n_sim, success_rate_diff)  ggplot(df_plot_conv, aes(x = n_sim, y = success_rate_diff, color = model_name)) +   geom_point() +   geom_line() +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey\")+   scale_x_continuous(breaks = unique(df_plot_conv$n_sim)[-c(2, 3)]) +   scale_y_continuous(breaks = c(-0.05, 0, 0.05, 0.1, 0.15)) +   labs(     title   = \"Success Rate Difference vs Number of Simulations\",     x       = \"Number of Simulations\",     y       = \"Success Rate Difference\",     color   = \"True Model Shape\",     caption = \"The success rate difference is the difference of the success rates calculated      with BayesianMCPMod and the power values calculated with MCPModPack.\") +   theme_minimal() +    theme(panel.grid.minor.x = element_blank())"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"background-and-data","dir":"Articles","previous_headings":"","what":"Background and Data","title":"Trial Simulation Example of Bayesian MCPMod for Continuous Data","text":"vignette, show use BayesianMCPMod R package trial planning continuously distributed data. analysis example vignette, focus indication MDD make use historical data included clinDR package. specifically, trial results BRINTELLIX utilized establish informative prior control group. general overview R package provided poster presented PSI 2024 Conference. package makes use future framework parallel processing, can set example follows: Kindly note due overhead reduced number worker nodes can preferable short calculations sequential execution can faster.","code":"future::plan(future::multisession, workers = 4L)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP Prior","title":"Trial Simulation Example of Bayesian MCPMod for Continuous Data","text":"first step, meta analytic predictive prior calculated using historical data 5 trials main endpoint Change baseline MADRS score 8 weeks. Please note information control group integrated leading informative mixture prior control group, active groups non-informative prior specified. make use getPriorList() function analysis example vignette create MAP prior. Kindly note vague prior implemented via","code":"data(\"metaData\") testdata    <- as.data.frame(metaData) dataset     <- filter(testdata, bname == \"BRINTELLIX\") histcontrol <- filter(dataset, dose == 0, primtime == 8, indication == \"MAJOR DEPRESSIVE DISORDER\")  hist_data <- data.frame(   trial = histcontrol$nctno,   est   = histcontrol$rslt,   se    = histcontrol$se,   sd    = histcontrol$sd,   n     = histcontrol$sampsize)  sd_tot <- with(hist_data, sum(sd * n) / sum(n)) dose_levels <- c(0, 2.5, 5, 10, 20)  prior_list  <- getPriorList(   hist_data     = hist_data,   dose_levels   = dose_levels,   robust_weight = 0.3) prior_list_vague <- rep(list(RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1),                                             sigma = sd_sim, param = \"mn\")),                         times = length(dose_levels)) names(prior_list_vague) <- c(\"Ctrl\", \"DG_1\", \"DG_2\", \"DG_3\", \"DG_4\")"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"specification-of-the-new-trial-design","dir":"Articles","previous_headings":"","what":"Specification of the New Trial Design","title":"Trial Simulation Example of Bayesian MCPMod for Continuous Data","text":"hypothetical new trial, plan 4 active dose levels specify broad set potential dose-response relationships, including linear, exponential, emax 2 sigEMAX models. Furthermore, assume maximum effect -3 top control (.e. assuming active treatment can reduce MADRS score 8 weeks 15.8) plan trial 80 patients active groups 60 patients control.","code":"exp     <- DoseFinding::guesst(   d     = 5,   p     = c(0.2),   model = \"exponential\",   Maxd  = max(dose_levels))  emax    <- DoseFinding::guesst(   d     = 2.5,   p     = c(0.9),   model = \"emax\")  sigemax <- DoseFinding::guesst(   d     = c(2.5, 5),   p     = c(0.1, 0.6),   model = \"sigEmax\")  sigemax2 <- DoseFinding::guesst(   d     = c(2, 4),   p     = c(0.3, 0.8),   model = \"sigEmax\")  mods <- DoseFinding::Mods(   linear      = NULL,   emax        = emax,   exponential = exp,   sigEmax     = rbind(sigemax, sigemax2),   doses       = dose_levels,   maxEff      = -3,   placEff     = -12.8)  n_patients <- c(60, 80, 80, 80, 80)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"calculation-of-the-success-probabilities","dir":"Articles","previous_headings":"","what":"Calculation of the Success Probabilities","title":"Trial Simulation Example of Bayesian MCPMod for Continuous Data","text":"calculate success probabilities different assumed dose-response models specified trial design apply assessDesign function. illustration purposes, number simulated trial results reduced 100 example. alternative, evaluate design overall sample size allocating patients highest dose group control. specific trial setting adapted allocation ratio leads increased success probabilities assumed dose response relationships. Instead specifying assumed effects via models, also possible directly specify effects individual dose levels via dr_means input. allows e.g. also simulation scenarios prior-data conflict.","code":"set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   n_sim       = 100) # speed up example run-time  success_probabilities #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.68  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.59  0.21  0.59  0.48  0.36  #>  #> $emax #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.82  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.26  0.78  0.23  0.36  0.65  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.63  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.61  0.16  0.60  0.42  0.30  #>  #> $sigEmax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.82  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.63  0.52  0.58  0.73  0.76  #>  #> $sigEmax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.84  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.43  0.73  0.37  0.61  0.77  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.758 #> attr(,\"placEff\") #> [1] -12.8 #> attr(,\"maxEff\") #> [1] -3 #> attr(,\"sampleSize\") #> [1] 60 80 80 80 80 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0 set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities_uneq <- assessDesign(   n_patients  = c(80, 60, 60, 60, 120),   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   n_sim       = 100) # speed up example run-time success_probabilities_uneq #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.8  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.76  0.33  0.75  0.64  0.53  #>  #> $emax #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.88  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.45  0.82  0.39  0.56  0.73  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.79  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.76  0.30  0.76  0.64  0.51  #>  #> $sigEmax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.86  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.73  0.51  0.69  0.82  0.82  #>  #> $sigEmax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.89  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.57  0.77  0.56  0.68  0.82  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.844 #> attr(,\"placEff\") #> [1] -12.8 #> attr(,\"maxEff\") #> [1] -3 #> attr(,\"sampleSize\") #> [1]  80  60  60  60 120 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0 set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities_dr <- assessDesign(   n_patients  = c(60, 80, 80, 80, 80),   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   dr_means    = c(-12, -14, -15, -16, -17),   n_sim       = 100) # speed up example run-time success_probabilities_dr #> $dr_response #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.99  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.87  0.90  0.86  0.94  0.97  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.99 #> attr(,\"placEff\") #> [1] -12 #> attr(,\"maxEff\") #> [1] 5 #> attr(,\"sampleSize\") #> [1] 60 80 80 80 80 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"assessment-of-the-minimally-efficacious-dose","dir":"Articles","previous_headings":"","what":"Assessment of the Minimally Efficacious Dose","title":"Trial Simulation Example of Bayesian MCPMod for Continuous Data","text":"assessment Minimally Efficacious Dose (MED) integrated assessDesign() function via arguments delta evidence_level. argument delta provided, estimated model shapes used assess MED. arguments delta evidence_level provided, Bayesian decision rule form MED̂=arg mind∈{d1,…,dk}{Pr(f(d,θ̂)−f(d1,θ̂)>Δ)>γ}\\widehat{\\text{MED}} = \\text{arg min}_{d\\\\{d_1, \\dots, d_k\\}} \\left\\{ \\text{Pr}\\left(f(d, \\hat\\theta) - f(d_1, \\hat\\theta) > \\Delta\\right) > \\gamma \\right\\} applied, see also ?getMED(). computational cost Bayesian decision rule within assessDesign() function rather high depending number simulated trial outcomes, required quantiles need bootstrapped true model shape simulated outcome. Thus, using Bayesian decision rule assessing trial’s design recommended using parallel computing.","code":"set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities_med <- assessDesign(   n_patients  = c(60, 80, 80, 80, 80),   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   delta       = 2,   n_sim       = 100) # speed up example run-time success_probabilities_med #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.68  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.59  0.21  0.59  0.48  0.36  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 0.68  #>    Dose Level:  2.5  5.0 10.0 20.0  #>    MED Freq:   0.00 0.03 0.19 0.46  #>   MED not reached Freq:        0  #>   No success in MCP step Freq: 0.32  #>  #> $emax #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.82  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.26  0.78  0.23  0.36  0.65  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 0.8  #>    Dose Level:  2.5  5.0 10.0 20.0  #>    MED Freq:   0.51 0.09 0.14 0.06  #>   MED not reached Freq:        0.02  #>   No success in MCP step Freq: 0.18  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.63  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.61  0.16  0.60  0.42  0.30  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 0.63  #>    Dose Level:  2.5  5.0 10.0 20.0  #>    MED Freq:   0.00 0.02 0.16 0.45  #>   MED not reached Freq:        0  #>   No success in MCP step Freq: 0.37  #>  #> $sigEmax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.82  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.63  0.52  0.58  0.73  0.76  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 0.82  #>    Dose Level:  2.5  5.0 10.0 20.0  #>    MED Freq:   0.02 0.17 0.37 0.26  #>   MED not reached Freq:        0  #>   No success in MCP step Freq: 0.18  #>  #> $sigEmax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.84  #>   N Simulations:          100  #>    Model Shape:         lin  emax   exp sigE1 sigE2  #>    Significance Freq:  0.43  0.73  0.37  0.61  0.77  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 0.83  #>    Dose Level:  2.5  5.0 10.0 20.0  #>    MED Freq:   0.25 0.17 0.22 0.19  #>   MED not reached Freq:        0.01  #>   No success in MCP step Freq: 0.16  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.758 #> attr(,\"avgMEDIdentificationRate\") #> [1] 0.752 #> attr(,\"placEff\") #> [1] -12.8 #> attr(,\"maxEff\") #> [1] -3 #> attr(,\"sampleSize\") #> [1] 60 80 80 80 80 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example_Binary.html","id":"background-and-data","dir":"Articles","previous_headings":"","what":"Background and Data","title":"Trial Simulation Example of Bayesian MCPMod for Binary Data","text":"vignette, show use BayesianMCPMod R package trial planning binary data. setting main specifications need happen logit scale, see also binary analysis example vignette. Internally, BayesianMCPMod fits binary endpoints logit scale. function argument probability_scale controls whether outputs (summaries, predictions, plots) back-transformed probabilities. simulateData(), outcomes simulated response scale probability_scale = TRUE. getMED(), delta interpreted probability scale probability_scale = TRUE. analysis example vignette, make use historical data included clinDR package. specifically, trial results XELJANZ utilized establish informative prior control group. package makes use future framework parallel processing, can set example follows: Kindly note due overhead reduced number worker nodes can preferable short calculations sequential execution can faster.","code":"future::plan(future::multisession, workers = 4L)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example_Binary.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP Prior","title":"Trial Simulation Example of Bayesian MCPMod for Binary Data","text":"example, first step, meta analytic prior calculated. approach establish prior outlined binary analysis example vignette. Please note information control group integrated leading informative mixture prior control group, active groups non-informative prior specified. Kindly note vague prior implemented via","code":"data(\"metaData\") testdata    <- as.data.frame(metaData) dataset     <- filter(testdata, bname == \"XELJANZ\") histcontrol <- filter(dataset, dose == 0, primtime == 12, indication == \"RHEUMATOID ARTHRITIS\")  hist_data <- data.frame(   trial = histcontrol$nctno,   est   = histcontrol$rslt,   se    = histcontrol$se,   sd    = histcontrol$sd,   r     = round(histcontrol$sampsize*histcontrol$rslt),   n     = histcontrol$sampsize)  sd_tot <- with(hist_data, sum(sd * n) / sum(n)) dose_levels <- c(0, 2.5, 5, 10,20)  # 1) Establish MAP prior (beta mixture distribution)  set.seed(7015) # re-sets seed only for this example; remove in your analysis script map <- gMAP(   cbind(hist_data$r, hist_data$n - hist_data$r) ~ 1 | histcontrol$nctno,   family     = binomial,   tau.dist   = \"HalfNormal\",   tau.prior  = 0.5,   beta.prior = (1 / sqrt(0.1 * 0.9)),   warmup     = 1000,   iter       = 10000,   chains     = 2,   thin       = 1 ) ## Assuming default prior location   for beta: 0 prior <- automixfit(map) #fits mixture distribution from MCMC samples from above  p <- summary(prior)[1]  # 2) Robustify prior prior_rob <- RBesT::robustify(       priormix = prior,       mean     = 0.5,       weight   = 0.2)  # 3) Translate prior to logit scale (to approximate via normal mixture model) r         <- rmix(prior_rob, n = 1e4) log_r     <- logit(r) prior_ctr <- automixfit(log_r, type = \"norm\")  # Specification of reference scale (this follows the idea of [@Neuenschwander2016]).  sigma(prior_ctr) <- sqrt(1 / (p * (1 - p)))  # Specify a prior list prior_trt <- RBesT::mixnorm(     comp1 = c(w = 1, m = logit(summary(prior)[1]), n = 1),     sigma = sqrt(1/(p*(1-p))),     param = \"mn\")      prior_list <- c(list(prior_ctr),                   rep(x     = list(prior_trt),                       times = length(dose_levels[-1])))  dose_names        <- c(\"Ctr\", paste0(\"DG_\", seq_along(dose_levels[-1]))) names(prior_list) <- dose_names prior_list_vague <- rep(list(RBesT::mixnorm(   comp1 = c(w = 1, m = logit(p), n = 1),   sigma = sqrt(1 / (p * (1 - p))),   param = \"mn\" )), times = length(dose_levels)) names(prior_list_vague) <- c(\"Ctrl\", \"DG_1\", \"DG_2\", \"DG_3\", \"DG_4\")"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example_Binary.html","id":"specification-of-the-new-trial-design","dir":"Articles","previous_headings":"","what":"Specification of the New Trial Design","title":"Trial Simulation Example of Bayesian MCPMod for Binary Data","text":"hypothetical new trial, plan 4 active dose levels specify broad set potential dose-response relationships, including linear, exponential, emax, logistic sigEMAX models. Furthermore, assume maximum response rate 48% (resp. 30% top control) plan trial 40 patients active groups 30 patients control. Please note response rates need provided logit scale.","code":"n_patients <- c(30, 40, 40, 40, 40)  models <- Mods(   linear      = NULL,   sigEmax     = c(10, 5),   logistic    = c(11, 15),   exponential = 10,   emax        = 2,   doses       = dose_levels,   placEff     = RBesT::logit(0.18),   maxEff      = (RBesT::logit(0.48) - RBesT::logit(0.18)) )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example_Binary.html","id":"calculation-of-the-success-probabilities","dir":"Articles","previous_headings":"","what":"Calculation of the Success Probabilities","title":"Trial Simulation Example of Bayesian MCPMod for Binary Data","text":"calculate success probabilities different assumed dose-response models specified trial design apply assessDesign() function. interested success probability testing step, also assessment Minimally Efficacious Dose (MED). effect delta provided probability scale. case like see difference 20% compared control claim efficacy. illustration purposes, number simulated trial results reduced 100 example. alternative, evaluate design overall sample size allocating patients highest dose group control. second alternative use vague prior:","code":"set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities <- assessDesign(   n_patients        = n_patients,   mods              = models,   prior_list        = prior_list,   probability_scale = TRUE,   delta             = 0.2,   n_sim             = 100) # speed up example run-time success_probabilities ## $linear ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.96  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.91 0.90 0.91 0.89 0.73  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.88  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.05 0.83  ##   MED not reached Freq:        0.08  ##   No success in MCP step Freq: 0.04  ##  ## $sigEmax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.98 0.97 0.98 0.97 0.72  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.92  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.10 0.82  ##   MED not reached Freq:        0.07  ##   No success in MCP step Freq: 0.01  ##  ## $logistic ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.96 0.94 0.96 0.95 0.77  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.92  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.02 0.13 0.77  ##   MED not reached Freq:        0.07  ##   No success in MCP step Freq: 0.01  ##  ## $exponential ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.97  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.92 0.92 0.93 0.97 0.52  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.88  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.00 0.88  ##   MED not reached Freq:        0.09  ##   No success in MCP step Freq: 0.03  ##  ## $emax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.94  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.80 0.66 0.80 0.64 0.92  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.87  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.27 0.28 0.17 0.15  ##   MED not reached Freq:        0.07  ##   No success in MCP step Freq: 0.06  ##  ## attr(,\"avgSuccessRate\") ## [1] 0.97 ## attr(,\"avgMEDIdentificationRate\") ## [1] 0.894 ## attr(,\"placEff\") ## [1] -1.516347 ## attr(,\"maxEff\") ## [1] 1.436305 ## attr(,\"sampleSize\") ## [1] 30 40 40 40 40 ## attr(,\"priorESS\") ##       Ctr DG_1.mean DG_2.mean DG_3.mean DG_4.mean  ##      10.6       1.0       1.0       1.0       1.0 set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities_uneq <- assessDesign(   n_patients        = c(40, 30, 30, 30, 50),   mods              = models,   prior_list        = prior_list,   probability_scale = TRUE,   delta             = 0.2,   n_sim             = 100) # speed up example run-time success_probabilities_uneq ## $linear ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.98  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.94 0.95 0.94 0.93 0.86  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.88  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.02 0.09 0.77  ##   MED not reached Freq:        0.1  ##   No success in MCP step Freq: 0.02  ##  ## $sigEmax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.99 0.97 0.99 0.98 0.79  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.95  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.12 0.83  ##   MED not reached Freq:        0.04  ##   No success in MCP step Freq: 0.01  ##  ## $logistic ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.98  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.98 0.96 0.98 0.96 0.87  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.89  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.01 0.02 0.10 0.76  ##   MED not reached Freq:        0.09  ##   No success in MCP step Freq: 0.02  ##  ## $exponential ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.99 0.99 0.99 0.99 0.75  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.95  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.04 0.91  ##   MED not reached Freq:        0.04  ##   No success in MCP step Freq: 0.01  ##  ## $emax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.88 0.78 0.88 0.76 0.97  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.91  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.14 0.28 0.23 0.26  ##   MED not reached Freq:        0.08  ##   No success in MCP step Freq: 0.01  ##  ## attr(,\"avgSuccessRate\") ## [1] 0.986 ## attr(,\"avgMEDIdentificationRate\") ## [1] 0.916 ## attr(,\"placEff\") ## [1] -1.516347 ## attr(,\"maxEff\") ## [1] 1.436305 ## attr(,\"sampleSize\") ## [1] 40 30 30 30 50 ## attr(,\"priorESS\") ##       Ctr DG_1.mean DG_2.mean DG_3.mean DG_4.mean  ##      10.6       1.0       1.0       1.0       1.0 set.seed(7015) # re-sets seed only for this example; remove in your analysis script success_probabilities_vague <- assessDesign(   n_patients        = n_patients,   mods              = models,   prior_list        = prior_list_vague,   probability_scale = TRUE,   delta             = 0.2,   n_sim             = 100) # speed up example run-time success_probabilities_vague ## $linear ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.91  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.89 0.85 0.88 0.86 0.56  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.85  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.01 0.09 0.75  ##   MED not reached Freq:        0.06  ##   No success in MCP step Freq: 0.09  ##  ## $sigEmax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.99  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.97 0.97 0.97 0.96 0.65  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.91  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.13 0.78  ##   MED not reached Freq:        0.08  ##   No success in MCP step Freq: 0.01  ##  ## $logistic ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.97  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.94 0.93 0.94 0.92 0.69  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.9  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.05 0.14 0.71  ##   MED not reached Freq:        0.07  ##   No success in MCP step Freq: 0.03  ##  ## $exponential ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.96  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.91 0.91 0.92 0.96 0.49  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.86  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.00 0.00 0.01 0.85  ##   MED not reached Freq:        0.1  ##   No success in MCP step Freq: 0.04  ##  ## $emax ## Bayesian Multiple Comparison Procedure ##   Estimated Success Rate: 0.87  ##   N Simulations:          100  ##    Model Shape:        lin sigE  log  exp emax  ##    Significance Freq: 0.68 0.54 0.68 0.53 0.84  ## MED Assessment on Probability Scale ##   Selection Method:    avgFit  ##   Identification Rate: 0.83  ##    Dose Level:  2.5  5.0 10.0 20.0  ##    MED Freq:   0.23 0.27 0.11 0.22  ##   MED not reached Freq:        0.04  ##   No success in MCP step Freq: 0.13  ##  ## attr(,\"avgSuccessRate\") ## [1] 0.94 ## attr(,\"avgMEDIdentificationRate\") ## [1] 0.87 ## attr(,\"placEff\") ## [1] -1.516347 ## attr(,\"maxEff\") ## [1] 1.436305 ## attr(,\"sampleSize\") ## [1] 30 40 40 40 40 ## attr(,\"priorESS\") ## Ctrl.mean DG_1.mean DG_2.mean DG_3.mean DG_4.mean  ##         1         1         1         1         1"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"vignette demonstrates application BayesianMCPMod package analyzing phase 2 dose-finding trial using Bayesian MCPMod approach. general overview R package provided poster presented PSI 2024 Conference. package makes use future framework parallel processing, can set example follows: Kindly note due overhead reduced number worker nodes can preferable short calculations sequential execution can faster.","code":"future::plan(future::multisession, workers = 4L)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP Prior","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"first step, meta analytic prior calculated using historical data 4 trials main endpoint Change baseline MADRS score 8 weeks. Please note information control group integrated leading informative mixture prior control group, active groups non-informative prior specified. , suggest function construct list prior distributions different dose groups. function adapted needs example. applications may need different way construct prior distributions. dose levels investigated, prior distribution can constructed.","code":"data(\"metaData\") dataset     <- filter(as.data.frame(metaData), bname == \"BRINTELLIX\") histcontrol <- filter(   dataset,   dose       == 0,   primtime   == 8,   indication == \"MAJOR DEPRESSIVE DISORDER\",   protid     != 5)  hist_data   <- data.frame(   trial = histcontrol$nctno,   est   = histcontrol$rslt,   se    = histcontrol$se,   sd    = histcontrol$sd,   n     = histcontrol$sampsize) getPriorList <- function (      hist_data,   dose_levels,   dose_names    = NULL,   robust_weight = 0.5    ) {      sd_tot <- with(hist_data, sum(sd * n) / sum(n))      gmap <- RBesT::gMAP(     formula    = cbind(est, se) ~ 1 | trial,     weights    = hist_data$n,     data       = hist_data,     family     = gaussian,     beta.prior = cbind(0, 100 * sd_tot),     tau.dist   = \"HalfNormal\",     tau.prior  = cbind(0, sd_tot / 4))      prior_ctr <- RBesT::automixfit(gmap)      if (!is.null(robust_weight)) {          prior_ctr <- suppressMessages(RBesT::robustify(       priormix = prior_ctr,       weight   = robust_weight,       sigma    = sd_tot))        }      prior_trt <- RBesT::mixnorm(     comp1 = c(w = 1, m = summary(prior_ctr)[1], n = 1),     sigma = sd_tot,     param = \"mn\")      prior_list <- c(list(prior_ctr),                   rep(x     = list(prior_trt),                       times = length(dose_levels[-1])))      if (is.null(dose_names)) {          dose_names <- c(\"Ctr\", paste0(\"DG_\", seq_along(dose_levels[-1])))        }      names(prior_list) <- dose_names      return (prior_list)    } dose_levels <- c(0, 2.5, 5, 10)  set.seed(7015) # re-sets seed only for this example; remove in your analysis script prior_list  <- getPriorList(   hist_data     = hist_data,   dose_levels   = dose_levels,   robust_weight = 0.3)  getESS(prior_list) ##  Ctr DG_1 DG_2 DG_3  ## 19.7  1.0  1.0  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"dose-response-model-shapes","dir":"Articles","previous_headings":"","what":"Dose-Response Model Shapes","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"Candidate models specified using {DoseFinding} package. Models can parameterized using guesstimates directly providing distribution parameters. Note linear candidate model require parameterization. Note: LinLog model rarely used currently supported BayesianMCPMod. code , models “guesstimated” using DoseFinding::guesst function. d option usually takes single value (dose level), corresponding p maximum effect achieved d. cases, need provide information. instance, sigEmax requires pair d p values, exponential requires specification maximum dose trial (Maxd). See help files model specifications typing ?DoseFinding::guesst console course, can also specify models directly parameter scale (without using DoseFinding::guesst). example, can get betaMod model specifying delta1 delta2 parameters (scale assumed 1.2 maximum dose), quadratic model delta2 parameter. Now, can go ahead create Mods object, used remainder vignette.  mods object just created contains full model parameters, can helpful understanding guesstimates translated onto parameter scale. can see assumed treatment effects specified dose groups :","code":"# Guesstimate estimation exp_guesst  <- DoseFinding::guesst(   model = \"exponential\",    d = 5, p = 0.2, Maxd = max(dose_levels) ) emax_guesst <- DoseFinding::guesst(   model = \"emax\",   d = 2.5, p = 0.9 ) sigEmax_guesst <- DoseFinding::guesst(   model = \"sigEmax\",   d = c(2.5, 5), p = c(0.5, 0.95) ) logistic_guesst <- DoseFinding::guesst(   model = \"logistic\",   d = c(5, 10), p = c(0.1, 0.85) ) betaMod_params   <- c(delta1 = 1, delta2 = 1) quadratic_params <- c(delta2 = -0.1) mods <- DoseFinding::Mods(   linear      = NULL,   # guesstimate scale   exponential = exp_guesst,   emax        = emax_guesst,   sigEmax     = sigEmax_guesst,   logistic    = logistic_guesst,   # parameter scale   betaMod     = betaMod_params,   quadratic   = quadratic_params,   # Options for all models   doses       = dose_levels,   maxEff      = -1,   placEff     = -12.8 )  plot(mods) display_params_table(mods) knitr::kable(DoseFinding::getResp(mods, doses = dose_levels))"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"trial-data","dir":"Articles","previous_headings":"Dose-Response Model Shapes","what":"Trial Data","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"use trial ct.gov number NCT00735709 phase 2 trial data, available clinDR package (ClinicalTrials.gov 2024).","code":"data(\"metaData\")  trial_data <- dplyr::filter(   dplyr::filter(tibble::tibble(metaData), bname == \"BRINTELLIX\"),   primtime   == 8,   indication == \"MAJOR DEPRESSIVE DISORDER\",   protid     == 5 )  n_patients <- c(128, 124, 129, 122)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"posterior-calculation","dir":"Articles","previous_headings":"","what":"Posterior Calculation","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"first step Bayesian MCPMod, posterior calculated combining prior information estimated results trial (Fleischer F 2022).","code":"posterior <- getPosterior(   prior_list = prior_list,   mu_hat     = trial_data$rslt,   S_hat      = diag(trial_data$se^2),   calc_ess   = TRUE )  knitr::kable(summary(posterior))"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"bayesian-mcpmod-test-step","dir":"Articles","previous_headings":"","what":"Bayesian MCPMod Test Step","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"testing step Bayesian MCPMod executed using critical value probability scale pseudo-optimal contrast matrix. critical value calculated using (re-estimated) contrasts frequentist MCPMod ensure error control using weakly-informative priors. pseudo-optimal contrast matrix generated based variability posterior distribution (see (Fleischer F 2022) details). Please note different ways derive contrasts. following code shows implementation ways executed contrast specification used. Bayesian MCP testing step executed: Summary information: testing step significant, indicating non-flat dose-response shape. models significant, emax model indicating greatest deviation null hypothesis.","code":"set.seed(7015) # re-sets seed only for this example; remove in your analysis script crit_pval <- getCritProb(   mods           = mods,   dose_levels    = dose_levels,   cov_new_trial  = diag(trial_data$se^2),   alpha_crit_val = 0.05 )  contr_mat <- getContr(   mods          = mods,   dose_levels   = dose_levels,   cov_posterior = diag(summary(posterior)[, 2]^2) ) # i) the frequentist contrast contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   dose_weights   = n_patients,   prior_list     = prior_list) # ii) re-estimated frequentist contrasts contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   cov_new_trial  = diag(trial_data$se^2)) # iii)  Bayesian approach using number of patients for new trial and prior distribution contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   dose_weights   = n_patients,   prior_list     = prior_list) BMCP_result <- performBayesianMCP(   posterior_list = posterior,   contr          = contr_mat,    crit_prob_adj  = crit_pval) BMCP_result ## Bayesian Multiple Comparison Procedure ##   Significant:                   1  ##   Critical Probability:          0.9845439  ##   Maximum Posterior Probability: 0.9999998  ## Posterior Probabilities for Model Shapes ##                        lin       exp      emax      sigE       log     betaM      quad ##   Posterior Prob 0.9999581 0.9981522 0.9999998 0.9999985 0.9953674 0.9999930 0.9883779  ##   Significant            1         1         1         1         1         1         1  ## Average Posterior ESS ##   Dose Level:     Ctr  DG_1  DG_2  DG_3  ##   Avg Post ESS: 189.9 186.6 188.2 180.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"model-fitting-and-visualization","dir":"Articles","previous_headings":"","what":"Model Fitting and Visualization","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"model fitting step posterior distribution used basis. simplified full fitting performed. simplified fit, multivariate normal distribution control group approximated reduced one-dimensional normal distribution. actual fit (approximated posterior distribution) performed using generalized least squares criterion. contrast, full fit, non-linear optimization problem addressed via Nelder-Mead algorithm (Wikipedia 2024) implemented nloptr package. output fit includes information predicted effects included dose levels, generalized AIC, corresponding weights. considered case, simplified full fit similar, present full fit. Estimates dose levels included trial: Plots fitted dose-response models AIC-based average model:  assess uncertainty, one can additionally visualize credible bands (orange shaded areas, default levels 50% 95%). credible bands calculated bootstrap method follows: Samples posterior distribution drawn every sample simplified fitting step prediction performed. predictions used identify visualize specified quantiles.  bootstrap-based quantiles can also directly calculated via getBootstrapQuantiles() function sample model fits can bootstrapped using getBootstrapSamples(). example, 10 samples bootstrapped model fit. bootstrap quantiles include information absolute quantiles (sample_type=abs) also placebo-adjusted (resp. control-adjusted) quantiles (sample_type=diff). Technical note: median quantile bootstrap based procedure necessary similar main model fit, derived via different procedures. main fit (black line) minimizes residuals posterior distribution, bootstrap median median fit random sampling.","code":"# If simple = TRUE, uses approx posterior # Here we use complete posterior distribution model_fits <- getModelFits(   models      = mods,   dose_levels = dose_levels,   posterior   = posterior,   simple      = FALSE) display_params_table(stats::predict(model_fits, doses = c(0, 2.5, 4, 5, 7, 10))) plot(model_fits) plot(model_fits, cr_bands = TRUE) set.seed(7015) # re-sets seed only for this example; remove in your analysis script bootstrap_quantiles <- getBootstrapQuantiles(   model_fits = model_fits,   quantiles  = c(0.025, 0.5, 0.975),   doses      = c(0, 2.5, 4, 5, 7, 10),   n_samples  = 10) reactable::reactable(   data = bootstrap_quantiles |>     tidyr::pivot_wider(names_from = q_prob, values_from = q_val),   groupBy = \"model\",   columns = list(     dose    = colDef(format = list(aggregated = colFormat(suffix = \" dose\"))),     \"0.025\" = colDef(format = list(cell = colFormat(digits = 4))),     \"0.5\"   = colDef(format = list(cell = colFormat(digits = 4))),     \"0.975\" = colDef(format = list(cell = colFormat(digits = 4)))   ) )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"assessment-of-the-minimally-efficacious-dose","dir":"Articles","previous_headings":"","what":"Assessment of the Minimally Efficacious Dose","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"Minimally Efficacious Dose (MED) per model shape can assessed function getMED(). optional Bayesian decision rule MED assessment details, please see ?getMED().","code":"getMED(   delta       = 4,   model_fits  = model_fits,   dose_levels = seq(min(dose_levels), max(dose_levels), by = 0.01)) ##             avgFit betaMod emax exponential linear logistic quadratic sigEmax ## med_reached   1.00    1.00 1.00           0      0      1.0      1.00    1.00 ## med           4.86    5.01 4.88          NA     NA      3.8      4.59    5.25"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"additional-note","dir":"Articles","previous_headings":"Assessment of the Minimally Efficacious Dose","what":"Additional Note","title":"Trial Analysis Example of Bayesian MCPMod for Continuous Data","text":"Testing, modeling, MED assessment can also combined via performBayesianMCPMod():","code":"performBayesianMCPMod(   posterior_list   = posterior,   contr            = contr_mat,   crit_prob_adj    = crit_pval,   delta            = 4,   simple           = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"vignette demonstrates application BayesianMCPMod package binary endpoint. detailed introduction provided setting continuous endpoint (analysis example vignette). Binary endpoints require modeling logit scale. use migraine dataset DoseFinding package working example, contains response rates migraine treatment. prior (control group) based historical trial data. package makes use future framework parallel processing, can set example follows: Kindly note due overhead reduced number worker nodes can preferable short calculations sequential execution can faster.","code":"future::plan(future::multisession, workers = 4L)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"scale-conventions-in-bayesianmcpmod","dir":"Articles","previous_headings":"Introduction","what":"Scale Conventions in BayesianMCPMod","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"Internally, BayesianMCPMod fits binary endpoints logit scale. function argument probability_scale controls whether outputs (summaries, predictions, plots) back-transformed probabilities. simulateData(), outcomes simulated response scale probability_scale = TRUE. getMED(), delta interpreted probability scale probability_scale = TRUE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP Prior","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"example, first step, meta analytic prior calculated. prior based trials results Diener et al. (2011), Ho et al. (2008) Hewitt et al. (2011). , assume following historical results control group. Please note information control group integrated, leading informative mixture prior control group, non-informative prior specified active groups. approach establish MAP prior conducted 3 steps. First information historical trials used establish beta mixture MAP prior (family=binomial). next step prior robustified. Finally, since BayesianMCPMod procedures binary endpoints require prior logit scale, translate prior scale via sampling distribution, translating results logit scale approximating via fitting normal mixtures conjugate distributions. Please note options establish reasonable informative prior setting.","code":"trial <- c(\"trial_1\", \"trial_2\", \"trial_3\") n     <- c(70,  115, 147) # sample size per trial r     <- c( 6,   16,  16) # n responders per trial dose_levels <- c(0, 2.5, 5, 10, 20, 50, 100, 200)  # 1) Establish MAP prior (beta mixture distribution) set.seed(7015) # re-set seed only for this example; remove in your analysis script map <- gMAP(   cbind(r, n - r) ~ 1 | trial,   family     = binomial,   tau.dist   = \"HalfNormal\",   tau.prior  = 0.5,   beta.prior = (1 / sqrt(0.1 * 0.9)),   warmup     = 1000,   iter       = 10000,   chains     = 2,   thin       = 1 ) #> Assuming default prior location   for beta: 0 map #> Generalized Meta Analytic Predictive Prior Analysis #>  #> Call:  gMAP(formula = cbind(r, n - r) ~ 1 | trial, family = binomial,  #>     tau.dist = \"HalfNormal\", tau.prior = 0.5, beta.prior = (1/sqrt(0.1 *  #>         0.9)), iter = 10000, warmup = 1000, thin = 1, chains = 2) #>  #> Exchangeability tau strata: 1  #> Prediction tau stratum    : 1  #> Maximal Rhat              : 1  #>  #> Between-trial heterogeneity of tau prediction stratum #>   mean     sd   2.5%    50%  97.5%  #> 0.2710 0.2210 0.0106 0.2160 0.8290  #>  #> MAP Prior MCMC sample #>   mean     sd   2.5%    50%  97.5%  #> 0.1190 0.0494 0.0454 0.1130 0.2340  prior <- automixfit(map) #fits mixture distribution from MCMC samples from above p     <- summary(prior)[1]  # 2) Robustify prior prior_rob <- RBesT::robustify(priormix = prior,                               mean     = 0.5,                               weight   = 0.4)  # 3) Translate prior to logit scale (to approximate via normal mixture model) r                <- rmix(prior_rob, n = 1e4) log_r            <- RBesT::logit(r) prior_ctr        <- automixfit(log_r, type = \"norm\")  # Specification of reference scale (this follows the idea of [@Neuenschwander2016]). sigma(prior_ctr) <- sqrt(1 / (p * (1 - p)))  # Specify a prior list prior_trt <- RBesT::mixnorm(   comp1 = c(     w = 1,     m = logit(summary(prior)[1]),     n = 1   ),   sigma = sqrt(1 / (p * (1 - p))),   param = \"mn\" )  prior_list <- c(list(prior_ctr),                 rep(x     = list(prior_trt),                     times = length(dose_levels[-1])))  dose_names        <- c(\"Ctr\", paste0(\"DG_\", seq_along(dose_levels[-1]))) names(prior_list) <- dose_names"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"dose-response-model-shapes","dir":"Articles","previous_headings":"","what":"Dose-Response Model Shapes","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"Candidate models specified parameter scale using {DoseFinding} package. create Mods object, used remainder vignette. Please note models specified logit scale.","code":"models <- Mods(   linear      = NULL,   sigEmax     = c(50, 3),   quadratic   = -1 / 250,   logistic    = c(110, 15),   exponential = 80,   emax        = 10,   doses       = dose_levels,   placEff     = RBesT::logit(0.118),   maxEff      = RBesT::logit(0.3) - RBesT::logit(0.118) )  plot(models)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"trial-data","dir":"Articles","previous_headings":"Dose-Response Model Shapes","what":"Trial Data","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"use trial data migraine data set available DoseFinding package phase 2 trial data. apply logistic regression (without additional covariates) get estimates logit scale.","code":"data(\"migraine\") # data set from the DoseFinding package  doses_fact <- as.factor(dose_levels) n_patients <- migraine$ntrt resp_rate  <- migraine$painfree/n_patients  ## Execution of logistic regression and readout of parameters  ## Note that estimates are automatically on the logit scale. log_fit <- glm(resp_rate ~ doses_fact - 1, family = binomial, weights = n_patients) mu_hat  <- coef(log_fit) S_hat   <- vcov(log_fit)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"posterior-calculation","dir":"Articles","previous_headings":"","what":"Posterior Calculation","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"first step Bayesian MCPMod, posterior calculated combining prior information estimated results trial (Fleischer F 2022). summary posterior can provided probability scale.","code":"post_logit <- getPosterior(prior_list, mu_hat = mu_hat, S_hat  = S_hat) summary(post_logit, probability_scale = TRUE) #>           mean         sd       2.5%     50.0%     97.5% #> Ctr  0.1071168 0.02127962 0.06930686 0.1058282 0.1520040 #> DG_1 0.1359001 0.06177459 0.04833967 0.1248126 0.2859179 #> DG_2 0.1222136 0.05057452 0.04865093 0.1137505 0.2436500 #> DG_3 0.2562256 0.05432101 0.16104931 0.2524449 0.3726678 #> DG_4 0.1943149 0.04961478 0.11121906 0.1895612 0.3041997 #> DG_5 0.2184915 0.05083942 0.13146633 0.2142515 0.3293963 #> DG_6 0.2401204 0.05496681 0.14521827 0.2358212 0.3591977 #> DG_7 0.3618200 0.06188555 0.24769337 0.3594987 0.4889697"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"bayesian-mcpmod-test-step","dir":"Articles","previous_headings":"","what":"Bayesian MCPMod Test Step","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"testing step Bayesian MCPMod executed using critical value probability scale pseudo-optimal contrast matrix. contrast matrix generated based number patients per dose group, see Fleischer F (2022) details. Please note also options possible, e.g. using weight based observed variability. critical value calculated using (re-estimated) contrasts frequentist MCPMod ensure error control using weakly-informative priors. Bayesian MCP testing step executed: well noted evaluation happens logit scale. testing step significant, indicating non-flat dose-response shape. model shapes significant.","code":"contr_mat_prior <- getContr(   mods           = models,   dose_levels    = dose_levels,   dose_weights   = n_patients)  set.seed(7015) # re-sets seed only for this example; remove in your analysis script crit_pval <- getCritProb(   mods           = models,   dose_levels    = dose_levels,   cov_new_trial  = S_hat,   alpha_crit_val = 0.05 ) BMCP_result <- performBayesianMCP(   posterior_list = post_logit,   contr          = contr_mat_prior,    crit_prob_adj  = crit_pval) BMCP_result #> Bayesian Multiple Comparison Procedure #>   Significant:                   1  #>   Critical Probability:          0.9790239  #>   Maximum Posterior Probability: 0.99999  #> Posterior Probabilities for Model Shapes #>                        lin      sigE      quad       log       exp      emax #>   Posterior Prob 0.9999900 0.9999338 0.9998325 0.9999509 0.9999644 0.9999885  #>   Significant            1         1         1         1         1         1"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"model-fitting-and-visualization","dir":"Articles","previous_headings":"","what":"Model Fitting and Visualization","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"model fitting step posterior distribution used basis. simplified full fitting can performed. focusing simplified fit. Furthermore specify fit provided probability scale easier interpretation results. output fit includes information predicted effects included dose levels, generalized AIC, corresponding weights. Plots fitted dose-response models AIC-based average model including 80% 95% credible bands probability scale:  case models shown logit scale can done following way:  Estimates including predictions can shown via: bootstrap-based quantiles can also directly calculated via getBootstrapQuantiles() function sample model fits can bootstrapped using getBootstrapSamples(). example, 10 samples bootstrapped model fit.","code":"model_fits <- getModelFits(   models            = models,   dose_levels       = dose_levels,   posterior         = post_logit,   simple            = TRUE,   probability_scale = TRUE) plot(model_fits, cr_bands = TRUE) plot(model_fits, probability_scale = FALSE) display_params_table(stats::predict(model_fits, doses = c(0, 2.5, 10,150, 200))) set.seed(7015) # re-sets seed only for this example; remove in your analysis script bootstrap_quantiles <- getBootstrapQuantiles(   model_fits = model_fits,   quantiles  = c(0.025, 0.5, 0.975),   doses      = dose_levels,   n_samples  = 10)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"assessment-of-the-minimally-efficacious-dose","dir":"Articles","previous_headings":"","what":"Assessment of the Minimally Efficacious Dose","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"Minimally Efficacious Dose (MED) per model shape can assessed function getMED(). effect needs specified probability scale.","code":"getMED(   delta       = 0.16, # on probability scale   model_fits  = model_fits,   dose_levels = seq(min(dose_levels), max(dose_levels), by = 1)) #>             avgFit emax exponential linear logistic quadratic sigEmax #> med_reached      1    1           1      1        1         1       1 #> med            118   59         161    153      117       121      78"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/binary_endpoint.html","id":"additional-note","dir":"Articles","previous_headings":"Assessment of the Minimally Efficacious Dose","what":"Additional Note","title":"Trial Analysis Example of Bayesian MCPMod for Binary Data","text":"Testing, modeling, MED assessment can also combined via performBayesianMCPMod():","code":"BMCPMod_result <- performBayesianMCPMod(   posterior_list    = post_logit,   contr             = contr_mat_prior,   crit_prob_adj     = crit_pval,   simple            = TRUE,   delta             = 0.16,   probability_scale = TRUE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Boehringer Ingelheim Pharma GmbH & Co. KG. Copyright holder, funder. Stephan Wojciekowski. Author, maintainer. Lars Andersen. Author. Jonas Schick. Contributor. Sebastian Bossert. Author.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wojciekowski, S, Andersen, L, Bossert, S (). BayesianMCPMod: Simulate, Evaluate, Analyze Dose Finding Trials Bayesian MCPMod. R package version 1.3.0.","code":"@Manual{,   title = {BayesianMCPMod: Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod},   author = {Stephan Wojciekowski and Lars Andersen and Sebastian Bossert},   note = {R package version 1.3.0},   url = {https://CRAN.R-project.org/package=BayesianMCPMod}, }"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"the-bayesianmcpmod-package","dir":"","previous_headings":"","what":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"Simulate, analyze, evaluate Bayesian MCPMod trials normally binary distributed endpoints. Bayesian MCPMod (Fleischer et al., 2022) innovative method improves traditional MCPMod systematically incorporating historical data, previous placebo group data. package offers functions simulating, analyzing, evaluating Bayesian MCPMod trials normally binary distributed endpoints. enables assessment trial designs incorporating historical data across various true dose-response relationships sample sizes. Robust mixture prior distributions, derived Meta-Analytic-Predictive approach (Schmidli et al., 2014), can specified dose group. Resulting mixture posterior distributions used Bayesian Multiple Comparison Procedure modeling steps. modeling step also includes weighted model averaging approach (Pinheiro et al., 2014). Estimated dose-response relationships can bootstrapped visualized.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"Install package CRAN using {r} install.packages(\"BayesianMCPMod\") development version can installed repository. {r} # install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/BayesianMCPmod\")","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"package documentation hosted .","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"assessDesign — assessDesign","title":"assessDesign — assessDesign","text":"function performs simulation based trial design evaluations set specified dose-response models","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"assessDesign — assessDesign","text":"","code":"assessDesign(   n_patients,   mods,   prior_list,   sd = NULL,   contr = NULL,   dr_means = NULL,   data_sim = NULL,   estimates_sim = NULL,   n_sim = 1000,   alpha_crit_val = 0.05,   modeling = FALSE,   simple = TRUE,   avg_fit = TRUE,   reestimate = FALSE,   delta = NULL,   evidence_level = NULL,   n_bs_samples = 1000,   med_selection = c(\"avgFit\", \"bestFit\"),   probability_scale = FALSE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"assessDesign — assessDesign","text":"n_patients Vector specifying planned number patients per dose group. minimum 2 patients required group. mods object class Mods specified DoseFinding package. prior_list prior_list object specifying utilized prior different dose groups sd positive value, specification assumed sd. required either data_sim estimates_sim provided. Also required case binary endpoint. Default NULL contr object class optContr created DoseFinding::getContr function. Allows specification fixed contrasts matrix. Default NULL. dr_means vector, allows specification individual (model based) assumed effects per dose group. Default NULL. data_sim optional data frame custom simulated data. Must follow data structure provided simulateData(). Default NULL. estimates_sim optional named list 1) list vectors estimated means per dose group (estimates_sim$mu_hats) 2) list matrices covariance matrices specifying (estimated) variabilities (estimates_sim$S_hats). Dimensions entries must match number dose levels. Default NULL. n_sim Number simulations performed alpha_crit_val (Un-adjusted) Critical value used MCP testing step. Passed getCritProb function calculation adjusted critical values (probability scale). Default 0.05. modeling Boolean variable defining whether Mod part Bayesian MCP-Mod performed assessment. heavy resources. Default FALSE. simple Boolean variable defining whether simplified fit applied, see ?getModelFits. Set automatically TRUE argument delta provided. Passed getModelFits Default TRUE. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. reestimate Boolean variable defining whether critical value calculated re-estimated contrasts (see getCritProb function details). Default FALSE. delta numeric value threshold Delta MED assessment. NULL, MED assessment performed. Default NULL. evidence_level numeric value 0 1 evidence level gamma MED assessment. required Bayesian MED assessment, see ?getMED details. NULL, MED assessment performed fitted model according argument med_selection.  Default NULL. n_bs_samples Number bootstrap samples MED assessment evidence_level provided. Note extreme quantiles (.e., quantiles closer 0 1) tend require bootstrap samples maintain precision. Default 1000. med_selection string, either \"avgFit\" \"bestFit\", method MED selection. Default \"avgFit\". probability_scale boolean specify trial continuous binary outcome. Setting TRUE transform calculations logit scale probability scale, can desirable binary outcome. Default FALSE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"assessDesign — assessDesign","text":"Returns success probabilities different assumed dose-response shapes, attributes also includes information around average success rate (across assumed models) prior Effective sample size.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"assessDesign — assessDesign","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           betaMod     = c(1, 1),                           doses       = c(0, 0.5, 2,4, 8),                           maxEff      = 6)                            sd <- 12 prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 12), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) n_patients <- c(40, 60, 60, 60, 60) dose_levels  <- c(0, 0.5, 2, 4, 8)  success_probabilities <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   sd          = sd,   n_sim       = 1e2) # speed up example run time  success_probabilities #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.86  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.81  0.60  0.75  0.74  0.31  #>  #> $emax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.88  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.57  0.81  0.78  0.24  0.74  #>  #> $emax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.9  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.70  0.81  0.83  0.43  0.79  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.85  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.81  0.33  0.54  0.83  0.04  #>  #> $betaMod #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.86  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.28  0.61  0.67  0.04  0.85  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.87 #> attr(,\"placEff\") #> [1] 0 #> attr(,\"maxEff\") #> [1] 6 #> attr(,\"sampleSize\") #> [1] 40 60 60 60 60 #> attr(,\"priorESS\") #> Ctrl DG_1 DG_2 DG_3 DG_4  #>    0    0    0    0    0   ## Analysis with custom data data_sim <- simulateData(   n_patients        = n_patients,   dose_levels       = dose_levels,   sd                = sd,   mods              = mods,   n_sim             = 10)  success_probabilities_cd <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   data_sim    = data_sim,   sd          = sd,   n_sim       = 1e2) # speed up example run time #> Consider to provide 'contr' for your custom simulated data or analysis results.  success_probabilities_cd #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 1  #>   N Simulations:          10  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:   1.0   0.6   0.8   0.9   0.1  #>  #> $emax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 1  #>   N Simulations:          10  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:   0.6   1.0   1.0   0.3   0.8  #>  #> $emax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 1  #>   N Simulations:          10  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:   0.8   1.0   1.0   0.4   0.9  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 1  #>   N Simulations:          10  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:   1.0   0.3   0.6   1.0   0.0  #>  #> $betaMod #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.9  #>   N Simulations:          10  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:   0.3   0.6   0.6   0.0   0.9  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.98 #> attr(,\"placEff\") #> [1] 0 #> attr(,\"maxEff\") #> [1] 6 #> attr(,\"sampleSize\") #> [1] 40 60 60 60 60 #> attr(,\"priorESS\") #> Ctrl DG_1 DG_2 DG_3 DG_4  #>    0    0    0    0    0   ## Analysis with custom dose response relationship custom_dr_means <- c(1, 2, 3, 4, 5)  success_probs_custom_dr <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   dr_means    = custom_dr_means,   sd          = sd,   n_sim       = 1e2) # speed up example run time  success_probs_custom_dr #> $dr_response #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.53  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.38  0.37  0.41  0.25  0.27  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.53 #> attr(,\"placEff\") #> [1] 1 #> attr(,\"maxEff\") #> [1] 4 #> attr(,\"sampleSize\") #> [1] 40 60 60 60 60 #> attr(,\"priorESS\") #> Ctrl DG_1 DG_2 DG_3 DG_4  #>    0    0    0    0    0   ## Analysis with custom estimates for means and variabilies ## No simulated data, only simulated model estimates estimates_sim <- list(mu_hats = replicate(100, list(c(1, 2, 3, 4, 5) + rnorm(5, 0, 1))),                       S_hats  = list(diag(1, 5)))  success_probs_custom_est <- assessDesign(   n_patients    = n_patients,   mods          = mods,   prior_list    = prior_list,   estimates_sim = estimates_sim) #> Consider to provide 'contr' for your custom simulated data or analysis results.  success_probs_custom_est #> $estimates_sim #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate: 0.92  #>   N Simulations:          100  #>    Model Shape:         lin emax1 emax2   exp betaM  #>    Significance Freq:  0.80  0.87  0.87  0.68  0.53  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.92 #> attr(,\"placEff\") #> [1] 0 #> attr(,\"maxEff\") #> [1] 6 #> attr(,\"sampleSize\") #> [1] 40 60 60 60 60 #> attr(,\"priorESS\") #> Ctrl DG_1 DG_2 DG_3 DG_4  #>    0    0    0    0    0   if (interactive()) { # takes typically > 5 seconds  # with MED estimation without bootstrapping # see ?getMED for details  success_probabilities <- assessDesign(   n_patients     = n_patients,   mods           = mods,   prior_list     = prior_list,   sd             = sd,   modeling       = TRUE,   n_sim          = 10, # speed up example run time   delta          = 7)    success_probabilities  # with MED estimation with bootstrapping  success_probabilities <- assessDesign(   n_patients     = n_patients,   mods           = mods,   prior_list     = prior_list,   sd             = sd,   modeling       = TRUE,   n_sim          = 10, # speed up example run time   delta          = 7,   evidence_level = 0.8)    success_probabilities  }"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"getBootstrapQuantiles — getBootstrapQuantiles","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"function calculation bootstrapped model predictions. Samples posterior distribution drawn (via RBesT function rmix()) every sample simplified fitting step (see getModelFits() function) prediction performed. fits used identify specified quantiles. approach can considered Bayesian equivalent frequentist bootstrap approach described O'Quigley et al. (2017). Instead drawing n bootstrap samples sampling distribution trial dose-response estimates, samples directly taken posterior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"","code":"getBootstrapQuantiles(   model_fits,   quantiles,   n_samples = 1000,   doses = NULL,   probability_scale = attr(model_fits, \"probability_scale\") )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"model_fits object class modelFits, .e. information fitted models & corresponding model coefficients well posterior distribution basis model fitting quantiles vector quantiles evaluated n_samples Number samples drawn basis bootstrapped quantiles doses vector doses prediction performed. NULL, dose levels model_fits used. Default NULL. probability_scale boolean variable specify trial continuous binary outcome. Setting TRUE transform predictions logit scale probability scale, can desirable binary outcome. Default attr(model_fits, \"probability_scale\").","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"tibble columns model, dose, bootstrapped samples","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"O'Quigley J, Iasonos , Bornkamp B. 2017. Handbook Methods Designing, Monitoring, Analyzing Dose-Finding Trials (1st ed.). Chapman Hall/CRC. doi:10.1201/9781315151984","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"exponential\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) model_fits     <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels,                                simple      = TRUE)  bs_quantiles <- getBootstrapQuantiles(model_fits = model_fits,                                       quantiles  = c(0.025, 0.5, 0.8, 0.975),                                       n_samples  = 10, # speeding up example run time                                       doses      = c(0, 6, 8))                        bs_quantiles #> # A tibble: 72 × 5 #>    model   dose sample_type q_prob   q_val #>    <chr>  <dbl> <chr>        <dbl>   <dbl> #>  1 avgFit     0 abs          0.025 -0.0692 #>  2 avgFit     0 abs          0.5    1.68   #>  3 avgFit     0 abs          0.8    2.18   #>  4 avgFit     0 abs          0.975  3.73   #>  5 avgFit     0 diff         0.025  0      #>  6 avgFit     0 diff         0.5    0      #>  7 avgFit     0 diff         0.8    0      #>  8 avgFit     0 diff         0.975  0      #>  9 avgFit     6 abs          0.025  5.03   #> 10 avgFit     6 abs          0.5    5.82   #> # ℹ 62 more rows"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":null,"dir":"Reference","previous_headings":"","what":"getBootstrapSamples — getBootstrapSamples","title":"getBootstrapSamples — getBootstrapSamples","text":"function return bootstrap samples fitted dose-response models. Samples posterior distribution drawn (via RBesT function rmix()) every sample simplified fitting step (see getModelFits() function) prediction performed. samples returned function. approach can considered Bayesian equivalent frequentist bootstrap approach described O'Quigley et al. (2017). Instead drawing n bootstrap samples sampling distribution trial dose-response estimates, samples directly taken posterior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBootstrapSamples — getBootstrapSamples","text":"","code":"getBootstrapSamples(   model_fits,   n_samples = 1000,   doses = NULL,   probability_scale = attr(model_fits, \"probability_scale\") )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBootstrapSamples — getBootstrapSamples","text":"model_fits object class modelFits, .e. information fitted models & corresponding model coefficients well posterior distribution basis model fitting n_samples Number samples drawn doses vector doses prediction performed probability_scale boolean variable specify trial continuous binary outcome. Setting TRUE transform predictions logit scale probability scale, can desirable binary outcome. Default attr(model_fits, \"probability_scale\").","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBootstrapSamples — getBootstrapSamples","text":"tibble columns sample_id, model, dose, sample, sample_diff","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getBootstrapSamples — getBootstrapSamples","text":"O'Quigley J, Iasonos , Bornkamp B. 2017. Handbook Methods Designing, Monitoring, Analyzing Dose-Finding Trials (1st ed.). Chapman Hall/CRC. doi:10.1201/9781315151984","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapSamples.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getBootstrapSamples — getBootstrapSamples","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                          DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"exponential\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) model_fits     <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels,                                simple      = TRUE)                             bs_samples <- getBootstrapSamples(model_fits = model_fits,                                   n_samples  = 10, # speeding up example run time                                   doses      = c(0, 6, 8))                        bs_samples #> # A tibble: 90 × 5 #>    sample_id model        dose   abs  diff #>        <int> <chr>       <dbl> <dbl> <dbl> #>  1         1 avgFit          0 0.998  0    #>  2         1 exponential     0 1.20   0    #>  3         1 linear          0 0.998  0    #>  4         1 avgFit          6 5.38   4.38 #>  5         1 exponential     6 5.15   3.95 #>  6         1 linear          6 5.38   4.38 #>  7         1 avgFit          8 6.84   5.84 #>  8         1 exponential     8 6.83   5.63 #>  9         1 linear          8 6.84   5.84 #> 10         2 avgFit          0 1.24   0    #> # ℹ 80 more rows"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":null,"dir":"Reference","previous_headings":"","what":"getContr — getContr","title":"getContr — getContr","text":"function calculates contrast vectors optimal detecting certain alternatives via applying function optContr() DoseFinding package. Hereby, 4 different options can distinguished automatically executed based input provided Bayesian approach: dose_weights prior_list provided optimized contrasts posterior sample size calculated. detail,  first step dose_weights (typically number patients per dose group) prior information combined calculating dose group posterior effective sample. Based posterior effective sample sizes allocation ratio derived, allows calculation pseudo-optimal contrasts via regular MCPMod calculated regular MCPMod specific weights Frequentist approach: dose_weights provided optimal contrast vectors calculated regular MCPMod specific weights Bayesian approach + re-estimation: cov_posterior (.e. variability posterior distribution) provided, pseudo-optimal contrasts based posterior weights calculated Frequentist approach+re-estimation: cov_new_trial (.e. estimated variability new trial) provided, optimal contrast vectors calculated regular MCPMod specific covariance matrix.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getContr — getContr","text":"","code":"getContr(   mods,   dose_levels,   dose_weights = NULL,   prior_list = NULL,   cov_posterior = NULL,   cov_new_trial = NULL )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getContr — getContr","text":"mods object class 'Mods' created function 'DoseFinding::Mods()' dose_levels Vector containing different dosage levels. dose_weights Vector specifying weights different doses. Please note case information provided together prior (.e. Option 1) planned two inputs provided scale (e.g. patient numbers).  Default NULL prior_list list objects class 'normMix' created 'RBesT::mixnorm()'. required input Option 1. Default NULL cov_posterior covariance matrix information variability posterior distribution, required Option 3. Default NULL cov_new_trial covariance matrix information observed variability, required Option 4. Default NULL","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getContr — getContr","text":"object class 'optContr' provided function 'DoseFinding::optContr()'.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getContr — getContr","text":"","code":"dose_levels  <- c(0, 0.5, 2, 4, 8) mods <- DoseFinding::Mods(   linear      = NULL,   emax        = c(0.5, 1.2),   exponential = 2,   doses       = dose_levels,   maxEff      = 6) cov_posterior <- diag(c(2.8, 3, 2.5, 3.5, 4)^2)  contr_mat <- getContr(   mods         = mods,   dose_levels  = dose_levels,   cov_posterior = cov_posterior)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":null,"dir":"Reference","previous_headings":"","what":"getCritProb — getCritProb","title":"getCritProb — getCritProb","text":"function calculates multiplicity adjusted critical values. critical values calculated way using non-informative priors actual error level falsely declaring significant trial Bayesian MCPMod controlled (specified alpha level). Hereby optimal contrasts frequentist MCPMod applied two options can distinguished Frequentist approach: dose_weights provided optimal contrast vectors calculated regular MCPMod specific weights corresponding critical value set contrasts calculated via critVal() function DoseFinding package. Frequentist approach + re-estimation: cov_new_trial (.e. covariance matrix new trial) provided, optimal contrast vectors calculated regular MCPMod specific matrix. well critical value set contrasts calculated via critVal() function DoseFinding package.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getCritProb — getCritProb","text":"","code":"getCritProb(   mods,   dose_levels,   dose_weights = NULL,   cov_new_trial = NULL,   alpha_crit_val = 0.025 )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getCritProb — getCritProb","text":"mods object class \"Mods\" specified DoseFinding package. dose_levels Vector containing different dosage levels. dose_weights Vector specifying weights different doses, required Option ). Default NULL cov_new_trial covariance matrix, required Option ii). Default NULL alpha_crit_val Significance level. Default set 0.025.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getCritProb — getCritProb","text":"Multiplicity adjusted critical value probability scale.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getCritProb — getCritProb","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels <- c(0, 0.5, 2, 4, 8) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50,50,50,50,50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.05)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":null,"dir":"Reference","previous_headings":"","what":"getESS — getESS","title":"getESS — getESS","text":"function calculates effective sample size every dose group via RBesT::ess().","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getESS — getESS","text":"","code":"getESS(post_list, method = c(\"elir\", \"moment\", \"morita\"), n_digits = 1, ...)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getESS — getESS","text":"post_list posterior list object, effective sample size dose group calculated method string specifying method ESS calculation, see ?RBesT::ess(). n_digits integer number digits result rounded . ... Optional arguments applicable specific methods, see ?RBesT::ess().","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getESS — getESS","text":"vector effective sample sizes dose group","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":null,"dir":"Reference","previous_headings":"","what":"getMED — getMED","title":"getMED — getMED","text":"function provides information minimally efficacious dose (MED). MED evaluation can either based fitted model shapes (model_fits) bootstrapped quantiles (bs_quantiles).","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getMED — getMED","text":"","code":"getMED(   delta,   evidence_level = 0.5,   dose_levels = NULL,   model_fits = NULL,   bs_quantiles = NULL,   probability_scale = attr(model_fits, \"probability_scale\") )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getMED — getMED","text":"delta numeric value threshold Delta. evidence_level numeric value 0 1 evidence level gamma. Used bs_quantiles-based evaluation used model_fits-based evaluation. Default 0.5. dose_levels vector numerics containing different dosage levels. Default NULL. model_fits object class modelFits created getModelFits(). Default NULL. bs_quantiles dataframe created getBootstrapQuantiles(). Default NULL. probability_scale boolean variable specify trial continuous binary outcome. Setting TRUE transform predictions logit scale probability scale, can desirable binary outcome. Default attr(model_fits, \"probability_scale\").","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getMED — getMED","text":"matrix rows MED reached, MED, MED index vector dose levels columns dose-response shapes.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getMED — getMED","text":"function assumes 1st dose group control dose group. bootstrap approach allows MED based decision rules form $$\\widehat{\\text{MED}} = \\text{arg min}_{d\\\\{d_1, \\dots, d_k\\}} \\left\\{ \\text{Pr}\\left(f(d, \\hat\\theta) - f(d_1, \\hat\\theta) > \\Delta\\right) > \\gamma \\right\\} .$$ model-shape approach takes point estimate model account.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getMED — getMED","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"exponential\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) model_fits     <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels,                                simple      = TRUE)  # MED based on the model_fit: getMED(delta = 5, model_fits = model_fits) #>             avgFit exponential linear #> med_reached      1           1      1 #> med              8           8      8                                 # MED based on bootstrapped quantiles bs_quantiles <- getBootstrapQuantiles(model_fits = model_fits,                                       quantiles  = c(0.025, 0.2, 0.5, 0.8),                                       n_samples  = 100) # speeding up example run time                                        getMED(delta          = 5,        evidence_level = 0.8,        bs_quantiles   = bs_quantiles) #>             avgFit exponential linear #> med_reached      0           0      0 #> med             NA          NA     NA         # MED on the probability scale getMED(delta = 0.1, model_fits = model_fits, probability_scale = TRUE) #>             avgFit exponential linear #> med_reached      1           1      1 #> med              2           2      2"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"getModelFits — getModelFits","title":"getModelFits — getModelFits","text":"Fits dose-response curves specified dose-response models, based posterior distributions. simplified fit, multivariate normal distributions approximated reduced one-dimensional normal distributions. default case, Nelder-Mead algorithm used. detail, approaches mean vector \\(\\theta^{Y}\\) covariance \\(\\Sigma\\) (mixture) posterior distributions corresponding posterior weights \\(\\tilde{\\omega}_{l}\\) \\(l \\{1,...,L}\\) used basis full fit GLS estimator used minimize following expression respective dose-response models \\(m\\) $$ \\hat{\\theta}_{m}=\\text{arg min}_{\\theta_{m}} \\sum_{l=1}^{L} \\tilde{\\omega}_{l}(\\theta_{l_{}}^{Y}-f(dose_{},\\hat{\\theta}_{m}))'\\Sigma_{l}^{-1}(\\theta_{l_{}}^{Y}-f(dose_{},\\hat{\\theta}_{m}))$$ Therefore function nloptr nloptr package utilized. simplified case \\(L=1\\), dimension posterior reduced 1 first. generalized AIC values calculated via formula $$gAIC_{m} = \\sum_{l=1}^{L} \\tilde{\\omega}_{l} \\sum_{=0}^{K} \\frac{1}{\\Sigma_{l_{,}}} (\\theta_{l_i}^Y - f(dose_{},\\hat{\\theta}_{m}))^2 + 2p $$ \\(p\\) denotes number estimated parameters \\(K\\) number active dose levels. well simplified case formula reduces one summand \\(L=1\\). Corresponding gAIC based weights model \\(M\\) calculated outlined Schorning et al. (2016) $$ \\Omega_I (M) = \\frac{\\exp(-0.5 gAIC_{M})}{\\sum_{m=1}^{Q} \\exp(-0.5 gAIC_{m})} $$ \\(Q\\) denotes number models included averaging procedure.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getModelFits — getModelFits","text":"","code":"getModelFits(   models,   dose_levels,   posterior,   avg_fit = TRUE,   simple = FALSE,   probability_scale = FALSE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getModelFits — getModelFits","text":"models Mods object created DoseFinding::Mods() vector model names fit performed. Implemented model shapes \"linear\", \"exponential\", \"logistic\", \"emax\", \"sigEmax\", \"quadratic\", \"betaMod\". dose_levels vector containing different dosage levels. posterior getPosterior object, containing (multivariate) posterior distribution per dosage level. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. simple Boolean variable, defining whether simplified fit applied. Default FALSE. probability_scale boolean variable specify predicted dose-response logit scale probability scale. Setting TRUE transform predictions logit scale probability scale, can desirable binary outcome. Default FALSE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getModelFits — getModelFits","text":"object class modelFits. list containing information fitted model coefficients, prediction per dose group well maximum effect generalized AIC (corresponding weight) per model.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getModelFits — getModelFits","text":"Schorning K, Bornkamp B, Bretz F, Dette H. 2016. Model selection versus model averaging dose finding studies. Stat Med; 35; 4021-4040.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getModelFits — getModelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2),                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2),                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"emax\", \"exponential\", \"sigEmax\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8)  fit        <- getModelFits(models      = models,                            posterior   = posterior_list,                            dose_levels = dose_levels)                             fit #> Model Coefficients #>   emax   e0 = 0, eMax = 8.1, ed50 = 1.7  #>   exp    e0 = 1.6, e1 = 8.8, delta = 16  #>   lin    e0 = 1.4, delta = 0.7  #>   sigE   e0 = 0, eMax = 7.5, ed50 = 1.5, h = 1.2  #> Dose Levels #>   Ctrl = 0, DG_1 = 1, DG_2 = 2, DG_3 = 4, DG_4 = 8  #> Predictions, Maximum Effect, gAIC & avgFit Model Weights #>          Ctrl DG_1 DG_2 DG_3 DG_4 mEff gAIC    w #>   avgFit  0.2  2.8  4.2  5.5  6.7  6.5   NA   NA  #>   emax    0.0  3.0  4.3  5.6  6.6  6.6  6.2  0.6  #>   exp     1.6  2.2  2.8  4.2  7.4  5.7 12.8  0.0  #>   lin     1.4  2.2  2.9  4.4  7.4  6.0  9.4  0.1  #>   sigE    0.0  2.9  4.4  5.7  6.6  6.6  8.1  0.2                              fit_simple <- getModelFits(models      = models,                            posterior   = posterior_list,                            dose_levels = dose_levels,                            simple      = TRUE)                             fit_simple #> Model Coefficients #>   emax   e0 = 0, eMax = 8.1, ed50 = 1.7  #>   exp    e0 = 1.6, e1 = 8.8, delta = 16  #>   lin    e0 = 1.4, delta = 0.7  #>   sigE   e0 = 0, eMax = 7.5, ed50 = 1.5, h = 1.2  #> Dose Levels #>   Ctrl = 0, DG_1 = 1, DG_2 = 2, DG_3 = 4, DG_4 = 8  #> Predictions, Maximum Effect, gAIC & avgFit Model Weights #>          Ctrl DG_1 DG_2 DG_3 DG_4 mEff gAIC    w #>   avgFit  0.2  2.8  4.2  5.5  6.7  6.5   NA   NA  #>   emax    0.0  3.0  4.3  5.6  6.6  6.6  6.2  0.6  #>   exp     1.6  2.2  2.8  4.2  7.4  5.7 12.8  0.0  #>   lin     1.4  2.2  2.9  4.4  7.4  6.0  9.4  0.1  #>   sigE    0.0  2.9  4.4  5.7  6.6  6.6  8.1  0.2"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":null,"dir":"Reference","previous_headings":"","what":"getPosterior — getPosterior","title":"getPosterior — getPosterior","text":"Either patient level data mu_hat well S_hat must provided. patient level data provided mu_hat S_hat calculated within function using linear model. function calculates posterior distribution. Depending input S_hat step either performed every dose group independently via RBesT function postmix() mvpostmix() function DoseFinding package utilized. latter case conjugate posterior mixture multivariate normals calculated (DeGroot 1970, Bernardo Smith 1994)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getPosterior — getPosterior","text":"","code":"getPosterior(   prior_list,   data = NULL,   mu_hat = NULL,   S_hat = NULL,   calc_ess = FALSE,   probability_scale = attr(data, \"probability_scale\") )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getPosterior — getPosterior","text":"prior_list prior list information prior used every dose group data dataframe containing information dose response. Also simulateData object can provided. Default NULL. mu_hat vector estimated mean values (per dose group). Default NULL. S_hat covariance matrix specifying (estimated) variability. variance-covariance matrix provided dimension matrix needs match number dose groups. Default NULL. calc_ess boolean variable, indicating whether effective sample size calculated. Default FALSE. probability_scale boolean specify trial continuous binary outcome. Setting TRUE transform calculations logit scale probability scale, can desirable binary outcome. Default attr(data, \"probability_scale\").","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getPosterior — getPosterior","text":"posterior_list, posterior list object returned information (mixture) posterior distribution per dose group (detailed information conjugate posterior case covariance input S_hat provided attributes)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getPosterior — getPosterior","text":"Kindly note one can sample posterior_list lapply(posterior_list, RBesT::rmix, n = 10).","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getPosterior — getPosterior","text":"BERNARDO, Jl. M., Smith, AFM (1994). Bayesian Theory. 81.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getPosterior — getPosterior","text":"","code":"prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2))                     mu_hat <- c(0, 1, 1.5, 2, 2.5) S_hat  <- diag(c(5, 4, 6, 7, 8)^2)  posterior_list <- getPosterior(    prior_list = prior_list,    mu_hat     = mu_hat,    S_hat      = S_hat)  summary(posterior_list) #>          mean       sd       2.5%    50.0%     97.5% #> Ctrl 0.000000 3.535534  -6.929519 0.000000  6.929519 #> DG_1 1.000000 3.794733  -6.437540 1.000000  8.437540 #> DG_2 1.431210 5.267373  -8.892652 1.431210 11.755072 #> DG_3 1.798235 5.905630  -9.776588 1.798235 13.373058 #> DG_4 2.362661 6.813267 -10.991096 2.362661 15.716418"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":null,"dir":"Reference","previous_headings":"","what":"performBayesianMCP — performBayesianMCP","title":"performBayesianMCP — performBayesianMCP","text":"Performs Bayesian MCP Test step, described Fleischer et al. (2022). Tests dose-response effect using model-based multiple contrast test based (provided) posterior distribution. particular every dose-response candidate posterior probability calculated contrast bigger 0 (based posterior distribution dose groups). order obtain significant test decision consider maximum posterior probabilities across different models. maximum compared (multiplicity adjusted) critical value (probability scale).","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"performBayesianMCP — performBayesianMCP","text":"","code":"performBayesianMCP(posterior_list, contr, crit_prob_adj)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"performBayesianMCP — performBayesianMCP","text":"posterior_list object derived getPosterior information (mixture) posterior distribution per dose group contr object class 'optContr' created getContr() function. contains contrast matrix used testing step. crit_prob_adj getCritProb object, specifying critical value used testing (probability scale)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"performBayesianMCP — performBayesianMCP","text":"Bayesian MCP test result, information p-values individual dose-response shapes overall significance","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"performBayesianMCP — performBayesianMCP","text":"Fleischer F, Bossert S, Deng Q, Loley C, Gierse J. 2022. Bayesian MCPMod. Pharmaceutical Statistics. 21(3): 654-670. doi:10.1002/pst.2193","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"performBayesianMCP — performBayesianMCP","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels  <- c(0, 0.5, 2, 4, 8) sd_posterior <- c(2.8,3,2.5,3.5,4) contr_mat <- getContr(   mods          = mods,   dose_levels   = dose_levels,   cov_posterior = diag(sd_posterior)^2) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.05) prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) mu <- c(0, 1, 1.5, 2, 2.5) S_hat <- diag(c(5, 4, 6, 7, 8)^2) posterior_list <- getPosterior(   prior_list = prior_list,   mu_hat     = mu,   S_hat      = S_hat,   calc_ess   = TRUE)  performBayesianMCP(posterior_list = posterior_list,                    contr          = contr_mat,                    crit_prob_adj  = critVal) #> Bayesian Multiple Comparison Procedure #>   Significant:                   0  #>   Critical Probability:          0.9752918  #>   Maximum Posterior Probability: 0.6412959  #> Posterior Probabilities for Model Shapes #>                        lin     emax1     emax2       exp #>   Posterior Prob 0.6191201 0.6412959 0.6410572 0.5839261  #>   Significant            0         0         0         0  #> Average Posterior ESS #>   Dose Level:   Ctrl DG_1 DG_2 DG_3 DG_4  #>   Avg Post ESS:  0.3  0.3  0.1  0.1  0.1"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":null,"dir":"Reference","previous_headings":"","what":"performBayesianMCPMod — performBayesianMCPMod","title":"performBayesianMCPMod — performBayesianMCPMod","text":"Performs Bayesian MCP Test step modeling combined fashion. See performBayesianMCP() function MCP Test step getModelFits() modeling step","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"performBayesianMCPMod — performBayesianMCPMod","text":"","code":"performBayesianMCPMod(   posterior_list,   contr,   crit_prob_adj,   simple = FALSE,   avg_fit = TRUE,   delta = NULL,   evidence_level = NULL,   med_selection = c(\"avgFit\", \"bestFit\"),   n_samples = 1000,   probability_scale = FALSE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"performBayesianMCPMod — performBayesianMCPMod","text":"posterior_list object class 'postList' list 'postList' objects created getPosterior() containing information (mixture) posterior distribution per dose group contr object class 'optContr' created getContr() function. contains contrast matrix used testing step. crit_prob_adj getCritProb object, specifying critical value used testing (probability scale). simple Boolean variable, defining whether simplified fit applied. Passed getModelFits() function. Default FALSE. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. delta numeric value threshold Delta MED assessment. NULL, MED assessment performed. Default NULL. evidence_level numeric value 0 1 evidence level gamma MED assessment. required Bayesian MED assessment, see ?getMED details. Default NULL. med_selection string, either \"avgFit\" \"bestFit\" based lowest gAIC, method MED selection. Default \"avgFit\". n_samples numerical number bootstrapped samples case Bayesian MED assessment performed. Default 1e3. probability_scale boolean specify trial continuous binary outcome. Setting TRUE transform calculations logit scale probability scale, can desirable binary outcome. Default FALSE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"performBayesianMCPMod — performBayesianMCPMod","text":"Bayesian MCP test result well modeling result.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"performBayesianMCPMod — performBayesianMCPMod","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels  <- c(0, 0.5, 2, 4, 8) sd_posterior <- c(2.8, 3, 2.5, 3.5, 4) contr_mat <- getContr(   mods          = mods,   dose_levels   = dose_levels,   cov_posterior = diag(sd_posterior)^2) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.6) # unreasonable alpha chosen for this example, rather choose 0.05 prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) mu <- c(0, 1, 1.5, 2, 2.5) S_hat <- diag(c(5, 4, 6, 7, 8)^2) posterior_list <- getPosterior(   prior_list = prior_list,   mu_hat     = mu,   S_hat      = S_hat,   calc_ess   = TRUE)  performBayesianMCPMod(posterior_list = posterior_list,                       contr          = contr_mat,                       crit_prob_adj  = critVal,                       simple         = FALSE,                       delta          = 1.1) #> Bayesian Multiple Comparison Procedure #>   Significant:                   1  #>   Critical Probability:          0.5701141  #>   Maximum Posterior Probability: 0.6412959  #> Posterior Probabilities for Model Shapes #>                        lin     emax1     emax2       exp #>   Posterior Prob 0.6191201 0.6412959 0.6410572 0.5839261  #>   Significant            1         1         1         1  #> Average Posterior ESS #>   Dose Level:   Ctrl DG_1 DG_2 DG_3 DG_4  #>   Avg Post ESS:  0.3  0.3  0.1  0.1  0.1  #> MED Assessment #>   Selection Method:    avgFit  #>   Identification Rate: 1  #>    Dose Level: 0.5 2.0 4.0 8.0  #>    MED Freq:     0   0   1   0  #>   MED not reached Freq:        0  #>   No success in MCP step Freq: 0  #> Model Coefficients #>   emax   e0 = 0, eMax = 2.2, ed50 = 0.8  #>   exp    e0 = 0.5, e1 = 3.4, delta = 16  #>   lin    e0 = 0.5, delta = 0.3  #> Dose Levels #>   Ctrl = 0, DG_1 = 0.5, DG_2 = 2, DG_3 = 4, DG_4 = 8  #> Predictions, Maximum Effect, gAIC, avgFit Model Weights & Significance #>          Ctrl DG_1 DG_2 DG_3 DG_4 mEff gAIC    w Sign #>   avgFit  0.4  0.7  1.2  1.6  2.6  2.2   NA   NA   NA  #>   emax    0.0  0.9  1.6  1.9  2.1  2.0  6.0  0.2  1.0  #>   exp     0.5  0.6  1.0  1.5  2.7  2.2  6.0  0.2  1.0  #>   lin     0.5  0.6  1.0  1.6  2.7  2.3  4.0  0.6  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.modelFits — plot.modelFits","title":"plot.modelFits — plot.modelFits","text":"Plot function based ggplot2 package. Providing visualizations model average Fit. Black lines show fitted dose response models AIC based average model. Dots indicate posterior median vertical lines show corresponding credible intervals (.e. variability posterior distribution respective dose group). assess uncertainty model fit one can addition visualize credible bands (default coloring orange shaded areas). calculation bands performed via getBootstrapQuantiles() function. default setting credible bands calculated.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.modelFits — plot.modelFits","text":"","code":"# S3 method for class 'modelFits' plot(   x,   probability_scale = attr(x, \"probability_scale\"),   gAIC = TRUE,   cr_intv = TRUE,   alpha_CrI = 0.05,   cr_bands = FALSE,   alpha_CrB = c(0.05, 0.2),   n_bs_smpl = 1000,   acc_color = \"orange\",   plot_res = 100,   plot_diffs = FALSE,   ... )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.modelFits — plot.modelFits","text":"x object type modelFits probability_scale boolean specify trial continuous binary outcome. Setting TRUE transform output logit scale probability scale, can desirable binary outcome. Default attr(x, \"probability_scale\"). gAIC Logical value indicating whether gAIC values shown plot. Default TRUE cr_intv Logical value indicating whether credible intervals included plot. Default TRUE alpha_CrI Numerical value width credible intervals. Default set 0.05 (.e 95% CI shown). cr_bands Logical value indicating whether bootstrapped based credible bands shown plot. Default FALSE alpha_CrB Numerical vector width credible bands. Default set 0.05 0.5 (.e 95% CB 50% CB  shown). n_bs_smpl Number bootstrap samples used. Default 1000. acc_color Color credible bands. Default \"orange\". plot_res Number plotted doses within range dose levels, .e., resolution plot. Default 100. plot_diffs Logical flag. Plot differences control group. Default FALSE. ... optional parameter passed plot().","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot.modelFits — plot.modelFits","text":"ggplot2 object","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot.modelFits — plot.modelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models <- c(\"exponential\", \"linear\", \"emax\") dose_levels <- c(0, 1, 2, 4, 8) model_fits <- getModelFits(models      = models,                            posterior   = posterior_list,                            dose_levels = dose_levels,                            simple       = TRUE)  plot(model_fits)   # plot with credible bands plot(model_fits,      cr_bands          = TRUE,      plot_diffs        = FALSE,      probability_scale = FALSE,      n_bs_smpl         = 1e2) # speeding up example run-time"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"predict.modelFits — predict.modelFits","title":"predict.modelFits — predict.modelFits","text":"function performs model predictions based provided model dose specifications","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predict.modelFits — predict.modelFits","text":"","code":"# S3 method for class 'modelFits' predict(   object,   doses = NULL,   probability_scale = attr(object, \"probability_scale\"),   ... )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predict.modelFits — predict.modelFits","text":"object modelFits object containing information fitted model coefficients doses vector specifying doses prediction done probability_scale boolean variable specify trial continuous binary outcome. Setting TRUE transform predictions logit scale probability scale, can desirable binary outcome. Default FALSE. ... Currently without function","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predict.modelFits — predict.modelFits","text":"list model predictions specified models doses","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"predict.modelFits — predict.modelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"emax\", \"exponential\", \"sigEmax\", \"linear\", \"betaMod\") dose_levels    <- c(0, 1, 2, 4, 8) fit            <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels)  predict(fit, doses = c(0, 1, 3, 4, 6, 8)) #> $avgFit #> [1] 0.1666128 2.8524723 4.9940076 5.5700609 6.3209477 6.6915166 #>  #> $betaMod #> [1] 0.006750219 2.896634290 5.209887329 5.930220025 6.745178458 6.507408210 #>  #> $emax #> [1] -0.008147777  2.977266585  5.136083687  5.647278697  6.271281080 #> [6]  6.637935274 #>  #> $exponential #> [1] 1.636554 2.207315 3.461645 4.150114 5.663125 7.377590 #>  #> $linear #> [1] 1.419597 2.167297 3.662695 4.410394 5.905792 7.401191 #>  #> $sigEmax #> [1] 0.00731386 2.89049046 5.22947029 5.72787171 6.28978958 6.59200716 #>  #> attr(,\"doses\") #> [1] 0 1 3 4 6 8"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":null,"dir":"Reference","previous_headings":"","what":"simulateData — simulateData","title":"simulateData — simulateData","text":"Function simulate patient level data normally distributed endpoint","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulateData — simulateData","text":"","code":"simulateData(   n_patients,   dose_levels,   sd = NULL,   mods = NULL,   n_sim = 1000,   true_model = NULL,   dr_means = NULL,   probability_scale = FALSE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulateData — simulateData","text":"n_patients Vector containing number patients numerical value per dose-group. dose_levels Vector containing different dosage levels. sd Standard deviation patient level. Can NULL probability_scale TRUE. Default NULL. mods object class \"Mods\" specified DoseFinding package. Can NULL ´dr_means´ NULL. Default NULL. n_sim Number simulations performed, Default 1000 true_model character model name, e.g. \"emax\". Assumed true underlying model. NULL, dose-response models included mods input parameter used. Default NULL. dr_means optional vector, information assumed effects per dose group. Default NULL. probability_scale boolean specify trial continuous binary outcome. Setting TRUE transform calculations logit scale probability scale, can desirable binary outcome. Default FALSE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulateData — simulateData","text":"list object, containing patient level simulated data assumed true models. Also providing information simulation iteration, patient number well dosage levels.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulateData — simulateData","text":"","code":"models <- DoseFinding::Mods(linear      = NULL,                             linlog      = NULL,                             emax        = c(0.5, 1.2),                             exponential = 2,                              doses       = c(0, 0.5, 2,4, 8),                             maxEff      = 6) dose_levels <- c(0, 0.5, 2, 4, 8) sd          <- 12 n_patients  <- c(40, 60, 60, 60, 60)  sim_data <- simulateData(n_patients  = n_patients,                          dose_levels = dose_levels,                          sd          = sd,                          mods        = models)  head(sim_data) #>   simulation ptno dose     linear     linlog      emax1      emax2 exponential #> 1          1    1    0  13.081588  13.081588  13.081588  13.081588   13.081588 #> 2          1    2    0   4.215108   4.215108   4.215108   4.215108    4.215108 #> 3          1    3    0 -13.124812 -13.124812 -13.124812 -13.124812  -13.124812 #> 4          1    4    0  -7.065638  -7.065638  -7.065638  -7.065638   -7.065638 #> 5          1    5    0  -6.195623  -6.195623  -6.195623  -6.195623   -6.195623 #> 6          1    6    0  17.412528  17.412528  17.412528  17.412528   17.412528  # custom response \"model\" shape custom_dose_response <- c(1, 2, 3, 4, 5) sim_data_custom_dr   <- simulateData(n_patients  = n_patients,                                      dose_levels = dose_levels,                                      sd          = sd,                                      dr_means    = custom_dose_response)  head(sim_data_custom_dr) #>   simulation ptno dose dr_response #> 1          1    1    0   20.716093 #> 2          1    2    0    4.075376 #> 3          1    3    0    1.454067 #> 4          1    4    0   13.761368 #> 5          1    5    0   -2.650874 #> 6          1    6    0   10.975242"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-130-xx-feb-2026","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.3.0 (XX-Feb-2026)","title":"BayesianMCPMod 1.3.0 (XX-Feb-2026)","text":"Fixed bug occur predicting beta model shape outside original dose range. Fixed bug MED assessment performed specifying negative direction beneficial effect evidence level 0.5. Added functions vignettes binary endpoint case. Added functionality assessDesign() provide custom simulated data custom model estimates enabling complex data simulation analysis methods. Added argument assessDesign() number bootstrap samples case evidence_level provided. Added functionality plot.modelFits() plot effect sizes. Added calls set.seed() vignette’s code blocks facilitate individual code block reproducibility.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-120-28-aug-2025","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.2.0 (28-Aug-2025)","title":"BayesianMCPMod 1.2.0 (28-Aug-2025)","text":"CRAN release: 2025-08-28 Fixed bug performBayesianMCPMod() model significance status MCP step sometimes correctly assigned fitted model Mod step. Fixed bug print.modelFit() sometimes coefficients fitted model shapes printed correctly. Fixed bug getMED() quantile evidence level sometimes matched due floating-point precision issues using bootstrapped quantiles. Changed functions getPosterior(), getCritProb(), getContr() accept covariance matrix instead standard deviation vector argument. Added support none-zero -diagonal covariance matrices MCP step. Added bootstrapped differences getBootstrapSamples(). Added average MED identification rate attribute assessDesign() output. Made future.apply package optional. Re-worked vignettes improved output print functions.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-110-07-mar-2025","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.1.0 (07-Mar-2025)","title":"BayesianMCPMod 1.1.0 (07-Mar-2025)","text":"CRAN release: 2025-03-07 Fixed bug plot.modelFits() plot credible bands based incorrectly selected bootstrapped quantiles. Added getMED(), function assess minimally efficacious dose (MED) integrated getMED() assessDesign() performBayesianMCPMod(). Added parallel processing using future framework. Modified handling fit average model: Now, getModelFits() argument fit average model carried forward subsequent functions. Re-introduced getBootstrapSamples(), separate function bootstrapping samples posterior distributions dose levels. Adapted vignettes new features.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-102-06-feb-2025","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.2 (06-Feb-2025)","title":"BayesianMCPMod 1.0.2 (06-Feb-2025)","text":"CRAN release: 2025-02-06 Addition new vignette comparing frequentist Bayesian MCPMod using vague priors. Extension getPosterior() allow input fully populated variance-covariance matrix. Added non-monotonic model shapes beta quadratic. New argument assessDesign() optionally skip Mod part MCPMod. Additional tests.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-101-03-apr-2024","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.1 (03-Apr-2024)","title":"BayesianMCPMod 1.0.1 (03-Apr-2024)","text":"CRAN release: 2024-04-05 Re-submission BayesianMCPMod package. Removed test occasionally failed fedora CRAN test system. Fixed bug getBootstrapQuantiles() return wrong bootstrapped quantiles. Added getBootstrapSamples(), separate function bootstrapping samples.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-100-31-dec-2023","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.0 (31-Dec-2023)","title":"BayesianMCPMod 1.0.0 (31-Dec-2023)","text":"CRAN release: 2024-01-08 Initial release BayesianMCPMod package. Special thanks Jana Gierse, Bjoern Bornkamp, Chen Yao, Marius Thomas & Mitchell Thomann review valuable comments. Thanks Kevin Kunzmann R infrastructure support Frank Fleischer methodological support.","code":""}]
