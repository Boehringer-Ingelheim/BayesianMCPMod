[{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Comparison of Bayesian MCPMod and MCPMod","text":"vignette demonstrates application BayesianMCPMod package sample size calculations comparison MCPModPack package. Bayesian MCPMod set way mimics results (operating characteristics) frequentist MCPMod vague priors. characteristic illustrated following sections focusing trial planning. following dose-finding scenario considered compare Bayesian MCPMod MCPModPack success probabilities: Four dose levels plus placebo (0 mg, 1 mg, 2 mg, 4 mg, 8 mg) Total sample size N = 200 equal allocation ratio dose group, .e., 40 per group Standard deviation 0.4 every dose group Alpha level 5% Simulations performed 10000 runs. Given number simulations applying law large numbers, difference success probabilities range 1% - 3%. following figure shows considered candidate models.","code":"doses_sim     <- c(0, 1, 2, 4, 8)  n_sample      <- c(40, 40, 40, 40, 40) sd_sim        <- 0.4  max_dose      <- max(doses_sim)     plc_eff_guess <- 0      alpha         <- 0.05 set.seed(7015) n_sim <- 10000  plan(multisession) registerDoFuture() emax_guess     <- guesst(d = doses_sim[2], p = 0.6, \"emax\")  exp_guess      <- guesst(d = doses_sim[2], p = 0.05, model = \"exponential\", Maxd = max_dose) logit_guess    <- guesst(d = c(doses_sim[2], doses_sim[3]), p = c(0.1, 0.9), \"logistic\", Maxd = max_dose)  sig_emax_guess <- guesst(d = c(doses_sim[2], doses_sim[3]), p = c(0.15, 0.75), model = \"sigEmax\")   plot(Mods(linear      = NULL,           exponential = exp_guess,           emax        = emax_guess,           logistic    = logit_guess,           sigEmax     = sig_emax_guess,           doses       = doses_sim,           placEff     = plc_eff_guess,           direction   = \"increasing\"),      main = \"Candidate Models\")"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"varying-the-expected-effect-for-maximum-dose","dir":"Articles","previous_headings":"","what":"Varying the Expected Effect for Maximum Dose","title":"Comparison of Bayesian MCPMod and MCPMod","text":"following expected effects studied: Expected effect maximum dose 0.0001, 0.05, 0.1, 0.2, 0.3, 0.5 value 0.0001 chosen instead 0 due technical reasons. case mimic null scenario (expect success probability close alpha level). following plot shows differences results obtained MCPModPack BayesianMCPMod. results BayesianMCPMod shown horizontal lines differences results MCPModPack presented vertical lines. results close one another, vertical lines barely visible. colours indicate different assumed true dose-response models, basis simulating data.  expected, operating characteristics BayesianMCPMod vague priors match operating characteristics frequentist MCPMod. Numerical results shown two tables .","code":"exp_eff <- c(0.0001, 0.05, 0.1, 0.2, 0.3, 0.5) # Simulation parameters sim_parameters <- list(n            = n_sample,                        doses        = doses_sim,                        dropout_rate = 0.0,                        go_threshold = 0.1,                        nsims        = n_sim)  # Candidate dose - response models models_MCPModPack = list(linear      = NA,                          exponential = exp_guess,                          emax        = emax_guess,                          logistic    = logit_guess,                          sigemax     = sig_emax_guess)  # Assumed dose - response models (models will be added in loop) sim_models_part <- list(max_effect     = exp_eff,                         sd             = rep(sd_sim, length(doses_sim)),                         placebo_effect = plc_eff_guess)  # Parallelization across assumed dose - response models powers_MCPModPack_eff <- foreach(   k = seq_along(models_MCPModPack),   .combine = cbind,    .options.future = list(seed = TRUE)) %dofuture% {          sim_model_k <- c(models_MCPModPack[k], sim_models_part)          MCPModSimulation(endpoint_type   = \"Normal\",                      models          = models_MCPModPack,                      alpha           = alpha,                      direction       = \"increasing\",                      model_selection = \"aveAIC\",                      Delta           = 0.1,                      sim_models      = sim_model_k,                      sim_parameters  = sim_parameters)$sim_results$power      }  # Post-processing result for printing colnames(powers_MCPModPack_eff) <- names(models_MCPModPack) results_MCPModPack_eff <- cbind(max_eff = round(exp_eff, digits = 2),                                 powers_MCPModPack_eff) %>%   data.frame() %>%   rename(sigEmax = sigemax) %>%   mutate(average = rowMeans(select(., linear:sigEmax))) # Vague prior specification prior_list_vague <- rep(list(RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1),                                             sigma = sd_sim, param = \"mn\")),                         times = length(doses_sim)) names(prior_list_vague) <- c(\"Ctrl\", \"DG_1\", \"DG_2\", \"DG_3\", \"DG_4\")  # Parallelization across the expected effects for maximum dose success_rates_BayesianMCPMod_eff <- foreach(   k               = seq_along(exp_eff),   .combine        = rbind,    .options.future = list(seed = TRUE)) %dofuture% {          exp_eff_k <- exp_eff[k]          models_BayesianMCPMod <- Mods(linear      = NULL,                                   exponential = exp_guess,                                   emax        = emax_guess,                                   logistic    = logit_guess,                                   sigEmax     = sig_emax_guess,                                   doses       = doses_sim,                                   placEff     = plc_eff_guess,                                   maxEff      = exp_eff_k,                                   direction   = \"increasing\")             # Optimal contrasts     contr <- getContr(mods         = models_BayesianMCPMod,                       dose_levels  = doses_sim,                       prior_list   = prior_list_vague,                       dose_weights = rep(1, length(doses_sim)))        # Perform Simulations     sim_result <- assessDesign(n_patients     = n_sample,                                mods           = models_BayesianMCPMod,                                prior_list     = prior_list_vague,                                sd             = sd_sim,                                n_sim          = n_sim,                                alpha_crit_val = alpha,                                contr          = contr)          c(sapply(sim_result, attr, \"successRate\"),       average = attr(sim_result, \"avgSuccessRate\"))      }  # Post-processing result for printing rownames(success_rates_BayesianMCPMod_eff) <- NULL results_BayesianMCPMod_eff <- data.frame(cbind(max_eff = round(exp_eff, digits = 2),                                            success_rates_BayesianMCPMod_eff)) ## pre-processing the data df_plot_eff <- rbind(results_MCPModPack_eff %>%                       mutate(package_name = \"MCPModPack\"),                      results_BayesianMCPMod_eff %>%                       mutate(package_name = \"BayesianMCPMod\")) %>%   pivot_longer(cols      = names(results_BayesianMCPMod_eff)[-1],                names_to  = \"model_shape\",                values_to = \"success_rate\") %>%   filter(model_shape != \"average\") %>%   spread(key = package_name, value = success_rate)  %>%   mutate(model_shape = as.factor(model_shape),          max_eff     = as.factor(max_eff)) %>%   group_by(max_eff) %>%   mutate(offset = 0.1 * (seq_along(model_shape) - ceiling(length(model_shape) / 2)))  # Plot with short horizontal dashes for each model_shape ggplot(df_plot_eff, aes(x = as.numeric(max_eff) + offset, y = BayesianMCPMod, color = model_shape)) +   geom_segment(aes(x = as.numeric(max_eff) + offset - 0.05, xend = as.numeric(max_eff) + offset + 0.05,                    y = BayesianMCPMod, yend = BayesianMCPMod)) +   geom_segment(aes(xend = as.numeric(max_eff) + offset, yend = MCPModPack)) +   scale_x_continuous(breaks = unique(as.numeric(df_plot_eff$max_eff)), labels = levels(df_plot_eff$max_eff)) +   labs(title    = \"Comparing Power and Success Rate\",        subtitle = \"For Different Expected Effects for Maximum Dose\",        x        = \"Expected Effect for Maximum Dose\",        y        = \"Success Rate / Power\",        color    = \"Assumed True Model Shapes\",        linetype = \"Type\",        caption  = \"Horizontal lines represent the BayesianMCPMod success rates and vertical lines mark the distance to the MCPModPack power.\") +   theme_minimal() +    theme(legend.position = \"bottom\") kable(results_MCPModPack_eff) %>%   kable_classic() %>%     add_header_above(c(\"Power Values Across Different Expected Effects\" = 7),                      font_size = 15, bold = TRUE) %>%     add_header_above(c(\"MCPModPack\" = 7), font_size = 15, bold = TRUE) kable(results_BayesianMCPMod_eff) %>%   kable_classic(full_width = TRUE) %>%     add_header_above(c(\"Success Rates Across Different Expected Effects\" = 7),                      font_size = 15, bold = TRUE) %>%     add_header_above(c(\"BayesianMCPMod\" = 7), font_size = 15, bold = TRUE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Comparison.html","id":"convergence-of-power-values","dir":"Articles","previous_headings":"","what":"Convergence of Power Values","title":"Comparison of Bayesian MCPMod and MCPMod","text":"following simulations, examine convergence power success rate values increasing number simulations. , expected maximum effect fixed 0.2. R package MCPModPack provides final power result given number simulations allow accessing intermediate power values. simulation repeated different values number simulations implementation MCPModPack. BayesianMCPMod implementation, one simulation run required access estimated success rate values different numbers simulations. figure shows convergence power success rate values increasing number simulations.  expected, differences within range 1% - 3%.","code":"exp_eff_fix <- 0.2 n_sim_vec <- seq(2, 10, 1)^4 # Updating the assumed dose - response models for the fixed expected effect (models will be added in loop) sim_models_part$max_effect <- exp_eff_fix  # Parallelization across assumed dose - response models & number of simulations ## Reversing the numbers speeds up parallelization in case there are not enough workers sim_grid <- expand.grid(names(models_MCPModPack), rev(n_sim_vec)) powers_MCPModPack_conv <- foreach(   k = seq_len(nrow(sim_grid)),   .combine = c,   .options.future = list(seed = TRUE)) %dofuture% {          sim_model_k <- c(models_MCPModPack[sim_grid[k, 1]], sim_models_part)          sim_params_k <- sim_parameters     sim_params_k$nsims <- sim_grid[k, 2]          MCPModSimulation(endpoint_type   = \"Normal\",                      models          = models_MCPModPack,                      alpha           = alpha,                      direction       = \"increasing\",                      model_selection = \"aveAIC\",                      Delta           = 0.1,                      sim_models      = sim_model_k,                      sim_parameters  = sim_params_k)$sim_results$power      }  #Post-processing results_MCPModPack_conv <- cbind(sim_grid, powers_MCPModPack_conv) %>%   arrange(desc(row_number())) %>%   rename(model_name   = Var1,          n_sim        = Var2,          success_rate = powers_MCPModPack_conv) %>%   mutate(model_name = if_else(model_name == \"sigemax\",                              \"sigEmax\", model_name)) %>%   mutate(package_name = \"MCPModPack\") # Model specifications with fixed expected effect models_BayesianMCPMod <- Mods(linear      = NULL,                               exponential = exp_guess,                               emax        = emax_guess,                               logistic    = logit_guess,                               sigEmax     = sig_emax_guess,                               doses       = doses_sim,                               placEff     = plc_eff_guess,                               maxEff      = exp_eff_fix,                               direction   = \"increasing\")         # Optimal contrasts contr <- getContr(mods         = models_BayesianMCPMod,                   dose_levels  = doses_sim,                   prior_list   = prior_list_vague,                   dose_weights = rep(1, length(doses_sim)))  # Perform Simulations sim_result <- assessDesign(n_patients     = n_sample,                            mods           = models_BayesianMCPMod,                            prior_list     = prior_list_vague,                            sd             = sd_sim,                            n_sim          = max(n_sim_vec),                            alpha_crit_val = alpha,                            contr          = contr)  # Getting success rates at different numbers of simulations results_BayesianMCPMod_conv <- sapply(sim_result, function (model_result) {      sapply(n_sim_vec, function (n_sim_x) {          success_rate_x <- mean(model_result[seq_len(n_sim_x), 1])        })    }) %>%   # Post-processing   as.data.frame %>%   mutate(n_sim = n_sim_vec) %>%   pivot_longer(cols = -n_sim,                names_to = \"model_name\",                values_to = \"success_rate\") %>%   mutate(package_name = \"BayesianMCPMod\") df_plot_conv <- inner_join(results_BayesianMCPMod_conv,                            results_MCPModPack_conv,                            by = c(\"model_name\", \"n_sim\")) %>%   mutate(success_rate_diff = success_rate.x - success_rate.y) %>%   select(model_name, n_sim, success_rate_diff)  ggplot(df_plot_conv, aes(x = n_sim, y = success_rate_diff, color = model_name)) +   geom_point() +   geom_line() +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"grey\")+   scale_x_continuous(breaks = unique(df_plot_conv$n_sim)[-c(2, 3)]) +   scale_y_continuous(breaks = c(-0.05, 0, 0.05, 0.1, 0.15)) +   labs(     title   = \"Success Rate Difference vs Number of Simulations\",     x       = \"Number of Simulations\",     y       = \"Success Rate Difference\",     color   = \"True Model Shape\",     caption = \"The success rate difference is the difference of the success rates calculated      with BayesianMCPMod and the power values calculated with MCPModPack.\") +   theme_minimal() +    theme(panel.grid.minor.x = element_blank())"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"background-and-data","dir":"Articles","previous_headings":"","what":"Background and data","title":"Simulation Example of Bayesian MCPMod for Continuous Data","text":"vignette, show use Bayesian MCPMod package trial planning continuous distributed data. analysis example vignette, focus indication MDD make use historical data included clinDR package. specifically, trial results BRINTELLIX utilized establish informative prior control group.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP prior","title":"Simulation Example of Bayesian MCPMod for Continuous Data","text":"first step, meta analytic predictive prior calculated using historical data 5 trials main endpoint Change baseline MADRS score 8 weeks. Please note information control group integrated leading informative mixture prior control group, active groups non-informative prior specified. make use getPriorList() function analysis example vignette create MAP prior.","code":"data(\"metaData\") testdata    <- as.data.frame(metaData) dataset     <- filter(testdata, bname == \"BRINTELLIX\") histcontrol <- filter(dataset, dose == 0, primtime == 8, indication == \"MAJOR DEPRESSIVE DISORDER\")  hist_data <- data.frame(   trial = histcontrol$nctno,   est   = histcontrol$rslt,   se    = histcontrol$se,   sd    = histcontrol$sd,   n     = histcontrol$sampsize)  sd_tot <- with(hist_data, sum(sd * n) / sum(n)) dose_levels <- c(0, 2.5, 5, 10, 20)  prior_list  <- getPriorList(   hist_data     = hist_data,   dose_levels   = dose_levels,   robust_weight = 0.3)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"specification-of-new-trial-design","dir":"Articles","previous_headings":"","what":"Specification of new trial design","title":"Simulation Example of Bayesian MCPMod for Continuous Data","text":"hypothetical new trial, plan 4 active dose levels specify broad set potential dose-response relationships, including linear, exponential, emax 2 sigEMAX models. Furthermore, assume maximum effect -3 top control (.e. assuming active treatment can reduce MADRS score 8 weeks 15.8) plan trial 80 patients active groups 60 patients control.","code":"exp     <- DoseFinding::guesst(   d     = 5,   p     = c(0.2),   model = \"exponential\",   Maxd  = max(dose_levels))  emax    <- DoseFinding::guesst(   d     = 2.5,   p     = c(0.9),   model = \"emax\")  sigemax <- DoseFinding::guesst(   d     = c(2.5, 5),   p     = c(0.1, 0.6),   model = \"sigEmax\")  sigemax2 <- DoseFinding::guesst(   d     = c(2, 4),   p     = c(0.3, 0.8),   model = \"sigEmax\")  mods <- DoseFinding::Mods(   linear      = NULL,   emax        = emax,   exponential = exp,   sigEmax     = rbind(sigemax, sigemax2),   doses       = dose_levels,   maxEff      = -3,   placEff     = -12.8)  n_patients <- c(60, 80, 80, 80, 80)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/Simulation_Example.html","id":"calculation-of-success-probabilities","dir":"Articles","previous_headings":"","what":"Calculation of success probabilities","title":"Simulation Example of Bayesian MCPMod for Continuous Data","text":"calculate success probabilities different assumed dose-response models specified trial design apply assessDesign function. illustration purposes, number simulated trial results reduced 100 example. alternative, evaluate design overall sample size allocating patients highest dose group control. specific trial setting adapted allocation ratio leads increased success probabilities assumed dose response relationships. Instead specifying assumed effects via models also possible directly specify effects individual dose levels via dr_means input. allows e.g. also simulation scenarios prior-data conflict.","code":"success_probabilities <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   n_sim       = 100) # speed up example run-time  success_probabilities #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.68  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.59        0.21        0.59        0.48        0.36  #>  #> $emax #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.82  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.26        0.78        0.23        0.36        0.65  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.63  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.61        0.16        0.60        0.42        0.30  #>  #> $sigEmax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.82  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.63        0.52        0.58        0.73        0.76  #>  #> $sigEmax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.84  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.43        0.73        0.37        0.61        0.77  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.758 #> attr(,\"placEff\") #> [1] -12.8 #> attr(,\"maxEff\") #> [1] -3 #> attr(,\"sampleSize\") #> [1] 60 80 80 80 80 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0 success_probabilities_uneq <- assessDesign(   n_patients  = c(80, 60, 60, 60, 120),   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   n_sim       = 100) # speed up example run-time success_probabilities_uneq #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.8  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.76        0.50        0.75        0.65        0.61  #>  #> $emax #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.84  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.39        0.83        0.34        0.59        0.76  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.81  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.76        0.48        0.76        0.64        0.59  #>  #> $sigEmax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.87  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.73        0.66        0.71        0.84        0.80  #>  #> $sigEmax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.86  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.58        0.79        0.52        0.75        0.81  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.836 #> attr(,\"placEff\") #> [1] -12.8 #> attr(,\"maxEff\") #> [1] -3 #> attr(,\"sampleSize\") #> [1]  80  60  60  60 120 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0 success_probabilities <- assessDesign(   n_patients  = c(60, 80, 80, 80, 80),   mods        = mods,   prior_list  = prior_list,   sd          = sd_tot,   dr_means    = c(-12, -14, -15, -16, -17),   n_sim       = 100) # speed up example run-time success_probabilities #> $dose_resp #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.99  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear        emax exponential    sigEmax1    sigEmax2  #>        0.90        0.89        0.88        0.88        0.91  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.99 #> attr(,\"placEff\") #> [1] -12 #> attr(,\"maxEff\") #> [1] 5 #> attr(,\"sampleSize\") #> [1] 60 80 80 80 80 #> attr(,\"priorESS\") #>  Ctr DG_1 DG_2 DG_3 DG_4  #> 20.6  1.0  1.0  1.0  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"vignette demonstrates application {BayesianMCPMod} package analyzing phase 2 dose-finding trial using Bayesian MCPMod approach.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"calculation-of-a-map-prior","dir":"Articles","previous_headings":"","what":"Calculation of a MAP prior","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"first step, meta analytic prior calculated using historical data 4 trials main endpoint Change baseline MADRS score 8 weeks. Please note information control group integrated leading informative mixture prior control group, active groups non-informative prior specified. , suggest function construct list prior distributions different dose groups. function adapted needs example. applications may need different way construct prior distributions. dose levels investigated, prior distribution can constructed.","code":"data(\"metaData\") dataset     <- filter(as.data.frame(metaData), bname == \"BRINTELLIX\") histcontrol <- filter(   dataset,   dose       == 0,   primtime   == 8,   indication == \"MAJOR DEPRESSIVE DISORDER\",   protid     != 5)  hist_data   <- data.frame(   trial = histcontrol$nctno,   est   = histcontrol$rslt,   se    = histcontrol$se,   sd    = histcontrol$sd,   n     = histcontrol$sampsize) getPriorList <- function (      hist_data,   dose_levels,   dose_names    = NULL,   robust_weight = 0.5    ) {      sd_tot <- with(hist_data, sum(sd * n) / sum(n))      gmap <- RBesT::gMAP(     formula    = cbind(est, se) ~ 1 | trial,     weights    = hist_data$n,     data       = hist_data,     family     = gaussian,     beta.prior = cbind(0, 100 * sd_tot),     tau.dist   = \"HalfNormal\",     tau.prior  = cbind(0, sd_tot / 4))      prior_ctr <- RBesT::automixfit(gmap)      if (!is.null(robust_weight)) {          prior_ctr <- suppressMessages(RBesT::robustify(       priormix = prior_ctr,       weight   = robust_weight,       sigma    = sd_tot))        }      prior_trt <- RBesT::mixnorm(     comp1 = c(w = 1, m = summary(prior_ctr)[1], n = 1),     sigma = sd_tot,     param = \"mn\")      prior_list <- c(list(prior_ctr),                   rep(x     = list(prior_trt),                       times = length(dose_levels[-1])))      if (is.null(dose_names)) {          dose_names <- c(\"Ctr\", paste0(\"DG_\", seq_along(dose_levels[-1])))        }      names(prior_list) <- dose_names      return (prior_list)    } dose_levels <- c(0, 2.5, 5, 10)  prior_list  <- getPriorList(   hist_data     = hist_data,   dose_levels   = dose_levels,   robust_weight = 0.3)  getESS(prior_list) ##  Ctr DG_1 DG_2 DG_3  ## 19.7  1.0  1.0  1.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"dose-response-model-shapes","dir":"Articles","previous_headings":"","what":"Dose-Response Model Shapes","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"Candidate models specified using {DoseFinding} package. Models can parameterized using guesstimates directly providing distribution parameters. Note linear candidate model require parameterization. Note: LinLog model rarely used currently supported BayesianMCPMod. code , models “guesstimated” using DoseFinding::guesst function. d option usually takes single value (dose level), corresponding p maximum effect achieved d. cases, need provide information. instance, sigEmax requires pair d p values, exponential requires specification maximum dose trial (Maxd). See help files model specifications typing ?DoseFinding::guesst console course, can also specify models directly parameter scale (without using DoseFinding::guesst). example, can get betaMod model specifying delta1 delta2 parameters (scale assumed 1.2 maximum dose), quadratic model delta2 parameter. Now, can go ahead create Mods object, used remainder vignette.  mods object just created contains full model parameters, can helpful understanding guesstimates translated onto parameter scale. can see assumed treatment effects specified dose groups :","code":"# Guesstimate estimation exp_guesst  <- DoseFinding::guesst(   model = \"exponential\",    d = 5, p = 0.2, Maxd = max(dose_levels) ) emax_guesst <- DoseFinding::guesst(   model = \"emax\",   d = 2.5, p = 0.9 ) sigEmax_guesst <- DoseFinding::guesst(   model = \"sigEmax\",   d = c(2.5, 5), p = c(0.5, 0.95) ) logistic_guesst <- DoseFinding::guesst(   model = \"logistic\",   d = c(5, 10), p = c(0.1, 0.85) ) betaMod_params <- c(delta1 = 1, delta2 = 1) quadratic_params <- c(delta2 = -0.1) mods <- DoseFinding::Mods(   linear      = NULL,   # guesstimate scale   exponential = exp_guesst,   emax        = emax_guesst,   sigEmax     = sigEmax_guesst,   logistic    = logistic_guesst,   # parameter scale   betaMod     = betaMod_params,   quadratic   = quadratic_params,   # Options for all models   doses       = dose_levels,   maxEff      = -1,   placEff     = -12.8 )  plot(mods) display_params_table(mods) knitr::kable(DoseFinding::getResp(mods, doses = dose_levels))"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"trial-data","dir":"Articles","previous_headings":"Dose-Response Model Shapes","what":"Trial Data","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"use trial ct.gov number NCT00735709 phase 2 trial data, available {clinDR} package [@nct00735709_2024a].","code":"data(\"metaData\")  trial_data <- dplyr::filter(   dplyr::filter(tibble::tibble(metaData), bname == \"BRINTELLIX\"),   primtime == 8,   indication == \"MAJOR DEPRESSIVE DISORDER\",   protid == 5 )  n_patients <- c(128, 124, 129, 122)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"posterior-calculation","dir":"Articles","previous_headings":"","what":"Posterior Calculation","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"first step Bayesian MCPMod, posterior calculated combining prior information estimated results trial [@fleischer_2022].","code":"posterior <- getPosterior(   prior_list = prior_list,   mu_hat = trial_data$rslt,   S_hat = trial_data$se,   calc_ess = TRUE )  knitr::kable(summary(posterior))"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"bayesian-mcpmod-test-step","dir":"Articles","previous_headings":"","what":"Bayesian MCPMod Test Step","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"testing step Bayesian MCPMod executed using critical value probability scale pseudo-optimal contrast matrix. critical value calculated using (re-estimated) contrasts frequentist MCPMod ensure error control using weakly-informative priors. pseudo-optimal contrast matrix generated based variability posterior distribution (see [@fleischer_2022] details). Please note different ways derive contrasts. following code shows implementation ways executed contrast specification used. Bayesian MCP testing step executed: Summary information: testing step significant, indicating non-flat dose-response shape. models significant, emax model indicating greatest deviation null hypothesis.","code":"crit_pval <- getCritProb(   mods           = mods,   dose_levels    = dose_levels,   se_new_trial   = trial_data$se,   alpha_crit_val = 0.05 )  contr_mat <- getContr(   mods         = mods,   dose_levels  = dose_levels,   sd_posterior = summary(posterior)[, 2] ) # i) the frequentist contrast contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   dose_weights   = n_patients,   prior_list     = prior_list) # ii) re-estimated frequentist contrasts contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   se_new_trial   = trial_data$se) # iii)  Bayesian approach using number of patients for new trial and prior distribution contr_mat_prior <- getContr(   mods           = mods,   dose_levels    = dose_levels,   dose_weights   = n_patients,   prior_list     = prior_list) BMCP_result <- performBayesianMCP(   posterior_list = posterior,   contr          = contr_mat,    crit_prob_adj  = crit_pval) BMCP_result ## Bayesian Multiple Comparison Procedure ## Summary: ##   Sign: 1  ##   Critical Probability: 0.9842778  ##   Maximum Posterior Probability: 0.9999998  ##  ## Posterior Probabilities for Model Shapes: ##        Model Probability ##       linear   0.9999581 ##  exponential   0.9981522 ##         emax   0.9999998 ##      sigEmax   0.9999985 ##     logistic   0.9953674 ##      betaMod   0.9999930 ##    quadratic   0.9883779 ## Average Posterior ESS ##   Ctr  DG_1  DG_2  DG_3  ## 189.9 186.6 188.2 180.0"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"model-fitting-and-visualization","dir":"Articles","previous_headings":"","what":"Model Fitting and Visualization","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"model fitting step posterior distribution used basis. simplified full fitting performed. simplified fit, multivariate normal distribution control group approximated reduced one-dimensional normal distribution. actual fit (approximated posterior distribution) performed using generalized least squares criterion. contrast, full fit, non-linear optimization problem addressed via Nelder-Mead algorithm [@neldermead_2024a] implemented nloptr package. output fit includes information predicted effects included dose levels, generalized AIC, corresponding weights. considered case, simplified full fit similar, present full fit. Estimates dose levels included trial: Plots fitted dose-response models AIC-based average model:  assess uncertainty, one can additionally visualize credible bands (orange shaded areas, default levels 50% 95%). credible bands calculated bootstrap method follows: Samples posterior distribution drawn every sample simplified fitting step prediction performed. predictions used identify visualize specified quantiles.  bootstrap based quantiles can also directly calculated via getBootstrapQuantiles() function. example, 6 quantiles bootstrapped model fit. Technical note: median quantile bootstrap based procedure necessary similar main model fit, derived via different procedures. main fit (black line) minimizes residuals posterior distribution, bootstrap median median fit random sampling.","code":"# If simple = TRUE, uses approx posterior # Here we use complete posterior distribution fit <- getModelFits(   models      = mods,   dose_levels = dose_levels,   posterior   = posterior,   simple      = FALSE) display_params_table(stats::predict(fit, doses = c(0, 2.5, 4, 5, 7, 10))) plot(fit) plot(fit, cr_bands = TRUE) bootstrap_quantiles <- getBootstrapQuantiles(   model_fits = fit,   quantiles  = c(0.025, 0.5, 0.975),   doses      = c(0, 2.5, 4, 5, 7, 10),   n_samples  = 6 ) reactable::reactable(   data = bootstrap_quantiles,   groupBy = \"models\",   columns = list(     doses = colDef(aggregate = \"count\", format = list(aggregated = colFormat(suffix = \" doses\"))),     \"2.5%\" = colDef(aggregate = \"mean\", format = list(aggregated = colFormat(prefix = \"mean = \", digits = 2), cell = colFormat(digits = 4))),     \"50%\" = colDef(aggregate = \"mean\", format = list(aggregated = colFormat(prefix = \"mean = \", digits = 2), cell = colFormat(digits = 4))),     \"97.5%\" = colDef(aggregate = \"mean\", format = list(aggregated = colFormat(prefix = \"mean = \", digits = 2), cell = colFormat(digits = 4)))   ) )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/articles/analysis_normal.html","id":"additional-note","dir":"Articles","previous_headings":"","what":"Additional note","title":"Analysis Example of Bayesian MCPMod for Continuous Data","text":"Testing modeling can also combined via performBayesianMCPMod(), run .","code":"performBayesianMCPMod(   posterior_list   = posterior,   contr            = contr_mat,   crit_prob_adj    = crit_pval,   simple           = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Boehringer Ingelheim Pharma GmbH & Co. KG. Copyright holder, funder. Stephan Wojciekowski. Author, maintainer. Lars Andersen. Author. Jonas Schick. Contributor. Sebastian Bossert. Author.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Wojciekowski, S, Andersen, L, Bossert, S (). BayesianMCPMod: Simulate, Evaluate, Analyze Dose Finding Trials Bayesian MCPMod. R package version 1.0.2.","code":"@Manual{,   title = {BayesianMCPMod: Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod},   author = {Stephan Wojciekowski and Lars Andersen and Sebastian Bossert},   note = {R package version 1.0.2},   url = {https://CRAN.R-project.org/package=bhmbasket}, }"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"the-bayesianmcpmod-package","dir":"","previous_headings":"","what":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"…","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"Install package CRAN using {r} install.packages(\"BayesianMCPMod\") development version can installed repository. {r} # install.packages(\"remotes\") remotes::install_github(\"https://github.com/Boehringer-Ingelheim/BayesianMCPmod\")","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"package documentation hosted .","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Simulate, Evaluate, and Analyze Dose Finding Trials with Bayesian MCPMod","text":"…","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":null,"dir":"Reference","previous_headings":"","what":"assessDesign — assessDesign","title":"assessDesign — assessDesign","text":"function performs simulation based trial design evaluations set specified dose-response models","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"assessDesign — assessDesign","text":"","code":"assessDesign(   n_patients,   mods,   prior_list,   sd,   n_sim = 1000,   alpha_crit_val = 0.05,   modeling = FALSE,   simple = TRUE,   avg_fit = TRUE,   reestimate = FALSE,   contr = NULL,   dr_means = NULL,   delta = NULL,   evidence_level = NULL,   med_selection = c(\"avgFit\", \"bestFit\") )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"assessDesign — assessDesign","text":"n_patients Vector specifying planned number patients per dose group. minimum 2 patients required group. mods object class \"Mods\" specified DoseFinding package. prior_list prior_list object specifying utilized prior different dose groups sd positive value, specification assumed sd n_sim Number simulations performed alpha_crit_val (Un-adjusted) Critical value used MCP testing step. Passed getCritProb() function calculation adjusted critical values (probability scale). Default 0.05. modeling Boolean variable defining whether Mod part Bayesian MCP-Mod performed assessment. heavy resources. Default FALSE. simple Boolean variable defining whether simplified fit applied. Passed getModelFits function. Default FALSE. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. reestimate Boolean variable defining whether critical value calculated re-estimated contrasts (see getCritProb function details). Default FALSE contr object class 'optContr' created getContr() function. Allows specification fixed contrasts matrix. Default NULL dr_means vector, allows specification  individual (model based) assumed effects per dose group. Default NULL delta numeric value threshold Delta MED assessment. NULL, MED assessment performed. Default NULL. evidence_level numeric value 0 1 evidence level gamma MED assessment. required Bayesian MED assessment, see ?getMED details. Default NULL. med_selection string, either \"avgFit\" \"bestFit\", method MED selection. Default \"avgFit\".","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"assessDesign — assessDesign","text":"Returns success probabilities different assumed dose-response shapes, attributes also includes information around average success rate (across assumed models) prior Effective sample size","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/assessDesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"assessDesign — assessDesign","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8),                           maxEff      = 6) sd <- 12 prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 12), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) n_patients <- c(40, 60, 60, 60, 60)  success_probabilities <- assessDesign(   n_patients  = n_patients,   mods        = mods,   prior_list  = prior_list,   sd          = sd,   n_sim       = 1e2) # speed up example run time  success_probabilities #> $linear #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.86  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear       emax1       emax2 exponential  #>        0.81        0.62        0.78        0.76  #>  #> $emax1 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.9  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear       emax1       emax2 exponential  #>        0.58        0.87        0.82        0.29  #>  #> $emax2 #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.9  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear       emax1       emax2 exponential  #>        0.72        0.87        0.85        0.46  #>  #> $exponential #> Bayesian Multiple Comparison Procedure #>   Estimated Success Rate:  0.89  #>   N Simulations:           100 #> Model Significance Frequencies #>      linear       emax1       emax2 exponential  #>        0.83        0.40        0.60        0.88  #>  #> attr(,\"avgSuccessRate\") #> [1] 0.8875 #> attr(,\"placEff\") #> [1] 0 #> attr(,\"maxEff\") #> [1] 6 #> attr(,\"sampleSize\") #> [1] 40 60 60 60 60 #> attr(,\"priorESS\") #> Ctrl DG_1 DG_2 DG_3 DG_4  #>    0    0    0    0    0   if (interactive()) { # takes typically > 5 seconds  # with MED estimation with bootstrapping # see ?getMED for details  success_probabilities <- assessDesign(   n_patients     = n_patients,   mods           = mods,   prior_list     = prior_list,   sd             = sd,   modeling       = TRUE,   n_sim          = 10, # speed up example run time   delta          = 7,   evidence_level = 0.8)      success_probabilities  }"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"getBootstrapQuantiles — getBootstrapQuantiles","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"function calculation bootstrapped model predictions. Samples posterior distribution drawn (via RBesT function rmix()) every sample simplified fitting step (see getModelFits() function) prediction performed. fits used identify specified quantiles. approach can considered Bayesian equivalent frequentist bootstrap approach described O'Quigley et al. (2017). Instead drawing n bootstrap samples sampling distribution trial dose-response estimates, samples directly taken posterior distribution.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"","code":"getBootstrapQuantiles(model_fits, quantiles, n_samples = 1000, doses = NULL)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"model_fits object class modelFits, .e. information fitted models & corresponding model coefficients well posterior distribution basis model fitting quantiles vector quantiles evaluated n_samples Number samples drawn basis bootstrapped quantiles doses vector doses prediction performed. NULL, dose levels model_fits used. Default NULL.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"data frame columns model, dose, bootstrapped samples","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"O'Quigley J, Iasonos , Bornkamp B. 2017. Handbook Methods Designing, Monitoring, Analyzing Dose-Finding Trials (1st ed.). Chapman Hall/CRC. doi:10.1201/9781315151984","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getBootstrapQuantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getBootstrapQuantiles — getBootstrapQuantiles","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"exponential\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) fit            <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels,                                simple      = TRUE)  getBootstrapQuantiles(model_fits = fit,                       quantiles  = c(0.025, 0.5, 0.8, 0.975),                       n_samples  = 10, # speeding up example run time                       doses      = c(0, 6, 8)) #>   doses      models       2.5%      50%      80%    97.5% #> 1     0 exponential  0.0149417 1.450540 2.013321 2.679536 #> 2     6 exponential  4.7215620 5.400230 6.139098 6.584165 #> 3     8 exponential  6.4387459 7.132410 7.921882 8.283815 #> 4     0      linear -0.2385774 1.252373 1.811166 2.476079 #> 5     6      linear  5.0043837 5.652031 6.384087 6.812547 #> 6     8      linear  6.5074929 7.167295 7.926906 8.289215 #> 7     0      avgFit -0.2385774 1.252373 1.811166 2.476079 #> 8     6      avgFit  5.0043837 5.652031 6.384087 6.812547 #> 9     8      avgFit  6.5074929 7.167295 7.926906 8.289215"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":null,"dir":"Reference","previous_headings":"","what":"getContr — getContr","title":"getContr — getContr","text":"function calculates contrast vectors optimal detecting certain alternatives via applying function optContr() DoseFinding package. Hereby 4 different options can distinguished automatically executed based input provided Bayesian approach: dose_weights prior_list provided optimized contrasts posterior sample size calculated. detail,  first step dose_weights (typically number patients per dose group) prior information combined calculating dose group posterior effective sample. Based posterior effective sample sizes allocation ratio derived, allows calculation pseudo-optimal contrasts via regular MCPMod calculated regular MCPMod specific weights Frequentist approach: dose_weights provided optimal contrast vectors calculated regular MCPMod specific weights Bayesian approach + re-estimation: sd_posterior (.e. variability posterior distribution) provided, pseudo-optimal contrasts based posterior weights calculated Frequentist approach+re-estimation: se_new_trial (.e. estimated variability per dose group new trial) provided, optimal contrast vectors calculated regular MCPMod specific vector standard errors. actual evaluation vector standard errors translated (diagonal) matrix variances","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getContr — getContr","text":"","code":"getContr(   mods,   dose_levels,   dose_weights = NULL,   prior_list = NULL,   sd_posterior = NULL,   se_new_trial = NULL )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getContr — getContr","text":"mods object class 'Mods' created function 'DoseFinding::Mods()' dose_levels Vector containing different dosage levels. dose_weights Vector specifying weights different doses. Please note case information provided together prior (.e. Option 1) planned two inputs provided scale (e.g. patient numbers).  Default NULL prior_list list objects class 'normMix' created 'RBesT::mixnorm()'. required input Option 1. Default NULL sd_posterior vector positive values information variability posterior distribution, required Option 3. Default NULL se_new_trial vector positive values information observed variability, required Option 4. Default NULL","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getContr — getContr","text":"object class 'optContr' provided function 'DoseFinding::optContr()'.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getContr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getContr — getContr","text":"","code":"dose_levels  <- c(0, 0.5, 2, 4, 8) mods <- DoseFinding::Mods(   linear      = NULL,   linlog      = NULL,   emax        = c(0.5, 1.2),   exponential = 2,   doses       = dose_levels,   maxEff      = 6) sd_posterior <- c(2.8, 3, 2.5, 3.5, 4)  contr_mat <- getContr(   mods         = mods,   dose_levels  = dose_levels,   sd_posterior = sd_posterior)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":null,"dir":"Reference","previous_headings":"","what":"getCritProb — getCritProb","title":"getCritProb — getCritProb","text":"function calculates multiplicity adjusted critical values. critical values calculated way using non-informative priors actual error level falsely declaring significant trial Bayesian MCPMod controlled (specified alpha level). Hereby optimal contrasts frequentist MCPMod applied two options can distinguished Frequentist approach: dose_weights provided optimal contrast vectors calculated regular MCPMod specific weights corresponding critical value set contrasts calculated via critVal() function DoseFinding package. Frequentist approach + re-estimation: se_new_trial (.e. estimated variability per dose group new trial) provided, optimal contrast vectors calculated regular MCPMod specific vector standard errors. well critical value set contrasts calculated via critVal() function DoseFinding package.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getCritProb — getCritProb","text":"","code":"getCritProb(   mods,   dose_levels,   dose_weights = NULL,   se_new_trial = NULL,   alpha_crit_val = 0.025 )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getCritProb — getCritProb","text":"mods object class \"Mods\" specified DoseFinding package. dose_levels Vector containing different dosage levels. dose_weights Vector specifying weights different doses, required Option ). Default NULL se_new_trial vector positive values, required Option ii). Default NULL alpha_crit_val Significance level. Default set 0.025.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getCritProb — getCritProb","text":"Multiplicity adjusted critical value probability scale.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getCritProb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getCritProb — getCritProb","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           linlog      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels <- c(0, 0.5, 2, 4, 8) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50,50,50,50,50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.05)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":null,"dir":"Reference","previous_headings":"","what":"getESS — getESS","title":"getESS — getESS","text":"function calculates effective sample size every dose group via RBesT function ess().","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getESS — getESS","text":"","code":"getESS(post_list)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getESS — getESS","text":"post_list posterior list object, effective sample size dose group calculated","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getESS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getESS — getESS","text":"vector effective sample sizes dose group","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":null,"dir":"Reference","previous_headings":"","what":"getMED — getMED","title":"getMED — getMED","text":"function provides information minimally efficacious dose (MED). MED evaluation can either based fitted model shapes (model_fits) bootstrapped quantiles (bs_quantiles).","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getMED — getMED","text":"","code":"getMED(   delta,   evidence_level = 0.5,   dose_levels = NULL,   model_fits = NULL,   bs_quantiles = NULL )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getMED — getMED","text":"delta numeric value threshold Delta. evidence_level numeric value 0 1 evidence level gamma. Used bs_quantiles-based evaluation used model_fits-based evaluation. Default 0.5. dose_levels vector numerics containing different dosage levels. Default NULL. model_fits object class modelFits created getModelFits(). Default NULL. bs_quantiles dataframe created getBootstrapQuantiles(). Default NULL.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getMED — getMED","text":"matrix rows MED reached, MED, MED index vector dose levels columns dose-response shapes.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"getMED — getMED","text":"function assumes 1st dose group control dose group. bootstrapp approach allows MED based decision rules form $$\\widehat{\\text{MED}} = \\text{arg min}_{d\\\\{d_1, \\dots, d_k\\}} \\left\\{ \\text{Pr}\\left(f(d, \\hat\\theta) - f(d_1, \\hat\\theta) > \\Delta\\right) > \\gamma \\right\\} .$$ model-shape approach takes point estimate model account.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getMED.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getMED — getMED","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"exponential\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) model_fits     <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels,                                simple      = TRUE)  # MED based on the model_fit: getMED(delta = 5, model_fits = model_fits) #>             exponential linear avgFit #> med_reached           1      1      1 #> med                   8      8      8                                 # MED based on bootstrapped quantiles bs_quantiles <- getBootstrapQuantiles(model_fits = model_fits,                                       quantiles  = c(0.025, 0.2, 0.5),                                       n_samples  = 100) # speeding up example run time                                        getMED(delta          = 5,        evidence_level = 0.8,        bs_quantiles   = bs_quantiles) #>             exponential linear avgFit #> med_reached           1      1      1 #> med                   8      8      8"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"getModelFits — getModelFits","title":"getModelFits — getModelFits","text":"Fits dose-response curves specified dose-response models, based posterior distributions. simplified fit, multivariate normal distributions approximated reduced one-dimensional normal distributions. default case, Nelder-Mead algorithm used. detail, approaches mean vector \\(\\theta^{Y}\\) covariance \\(\\Sigma\\) (mixture) posterior distributions corresponding posterior weights \\(\\tilde{\\omega}_{l}\\) \\(l \\{1,...,L}\\) used basis full fit GLS estimator used minimize following expression respective dose-response models \\(m\\) $$ \\hat{\\theta}_{m}=\\text{arg min}_{\\theta_{m}} \\sum_{l=1}^{L} \\tilde{\\omega}_{l}(\\theta_{l_{}}^{Y}-f(dose_{},\\hat{\\theta}_{m}))'\\Sigma_{l}^{-1}(\\theta_{l_{}}^{Y}-f(dose_{},\\hat{\\theta}_{m}))$$ Therefore function nloptr nloptr package utilized. simplified case \\(L=1\\), dimension posterior reduced 1 first. generalized AIC values calculated via formula $$gAIC_{m} = \\sum_{l=1}^{L} \\tilde{\\omega}_{l} \\sum_{=0}^{K} \\frac{1}{\\Sigma_{l_{,}}} (\\theta_{l_i}^Y - f(dose_{},\\hat{\\theta}_{m}))^2 + 2p $$ \\(p\\) denotes number estimated parameters \\(K\\) number active dose levels. well simplified case formula reduces one summand \\(L=1\\). Corresponding gAIC based weights model \\(M\\) calculated outlined Schorning et al. (2016) $$ \\Omega_I (M) = \\frac{\\exp(-0.5 gAIC_{M})}{\\sum_{m=1}^{Q} \\exp(-0.5 gAIC_{m})} $$ \\(Q\\) denotes number models included averaging procedure.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getModelFits — getModelFits","text":"","code":"getModelFits(models, dose_levels, posterior, avg_fit = TRUE, simple = FALSE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getModelFits — getModelFits","text":"models List (vector) model names fit performed. dose_levels vector containing different dosage levels. posterior getPosterior object, containing (multivariate) posterior distribution per dosage level. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. simple Boolean variable, defining whether simplified fit applied. Default FALSE.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getModelFits — getModelFits","text":"object class modelFits. list containing information fitted model coefficients, prediction per dose group well maximum effect generalized AIC (corresponding weight) per model.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getModelFits — getModelFits","text":"Schorning K, Bornkamp B, Bretz F, Dette H. 2016. Model selection versus model averaging dose finding studies. Stat Med; 35; 4021-4040.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getModelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getModelFits — getModelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"emax\", \"exponential\", \"sigEmax\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8)  fit        <- getModelFits(models      = models,                            posterior   = posterior_list,                            dose_levels = dose_levels) fit_simple <- getModelFits(models      = models,                            posterior   = posterior_list,                            dose_levels = dose_levels,                            simple      = TRUE)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":null,"dir":"Reference","previous_headings":"","what":"getPosterior — getPosterior","title":"getPosterior — getPosterior","text":"Either patient level data mu_hat well S_hat must provided. patient level data provided mu_hat S_hat calculated within function using linear model. function calculates posterior distribution. Depending input S_hat step either performed every dose group independently via RBesT function postmix() mvpostmix() function DoseFinding package utilized. latter case conjugate posterior mixture multivariate normals calculated (DeGroot 1970, Bernardo Smith 1994)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"getPosterior — getPosterior","text":"","code":"getPosterior(   prior_list,   data = NULL,   mu_hat = NULL,   S_hat = NULL,   calc_ess = FALSE )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"getPosterior — getPosterior","text":"prior_list prior list information prior used every dose group data dataframe containing information dose response. Default NULL Also simulateData object can provided. mu_hat vector estimated mean values (per dose group). S_hat Either vector covariance matrix specifying (estimated) variability can specified. length vector (resp. dimension matrix) needs match number dose groups. Please note vector input numbers reflect standard error per dose group (.e. square root variance), matrix input variance-covariance matrix provided. calc_ess boolean variable, indicating whether effective sample size calculated. Default FALSE","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"getPosterior — getPosterior","text":"posterior_list, posterior list object returned information (mixture) posterior distribution per dose group (detailed information conjugate posterior case covariance input S_hat provided attributes)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"getPosterior — getPosterior","text":"BERNARDO, Jl. M., Smith, AFM (1994). Bayesian Theory. 81.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/getPosterior.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"getPosterior — getPosterior","text":"","code":"prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) mu <- c(0, 1, 1.5, 2, 2.5) S_hat <- c(5, 4, 6, 7, 8)  posterior_list <- getPosterior(    prior_list = prior_list,    mu_hat     = mu,    S_hat     = S_hat)  summary(posterior_list) #>          mean       sd       2.5%    50.0%     97.5% #> Ctrl 0.000000 3.535534  -6.929519 0.000000  6.929519 #> DG_1 1.000000 3.794733  -6.437540 1.000000  8.437540 #> DG_2 1.431210 5.267373  -8.892652 1.431210 11.755072 #> DG_3 1.798235 5.905630  -9.776588 1.798235 13.373058 #> DG_4 2.362661 6.813267 -10.991096 2.362661 15.716418"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":null,"dir":"Reference","previous_headings":"","what":"performBayesianMCP — performBayesianMCP","title":"performBayesianMCP — performBayesianMCP","text":"Performs Bayesian MCP Test step, described Fleischer et al. (2022). Tests dose-response effect using model-based multiple contrast test based (provided) posterior distribution. particular every dose-response candidate posterior probability calculated contrast bigger 0 (based posterior distribution dose groups). order obtain significant test decision consider maximum posterior probabilities across different models. maximum compared (multiplicity adjusted) critical value (probability scale).","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"performBayesianMCP — performBayesianMCP","text":"","code":"performBayesianMCP(posterior_list, contr, crit_prob_adj)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"performBayesianMCP — performBayesianMCP","text":"posterior_list object derived getPosterior information (mixture) posterior distribution per dose group contr object class 'optContr' created getContr() function. contains contrast matrix used testing step. crit_prob_adj getCritProb object, specifying critical value used testing (probability scale)","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"performBayesianMCP — performBayesianMCP","text":"Bayesian MCP test result, information p-values individual dose-response shapes overall significance","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"performBayesianMCP — performBayesianMCP","text":"Fleischer F, Bossert S, Deng Q, Loley C, Gierse J. 2022. Bayesian MCPMod. Pharmaceutical Statistics. 21(3): 654-670. doi:10.1002/pst.2193","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"performBayesianMCP — performBayesianMCP","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           linlog      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels  <- c(0, 0.5, 2, 4, 8) sd_posterior <- c(2.8,3,2.5,3.5,4) contr_mat <- getContr(   mods         = mods,   dose_levels  = dose_levels,   sd_posterior = sd_posterior) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.05) prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) mu <- c(0, 1, 1.5, 2, 2.5) S_hat <- c(5, 4, 6, 7, 8) posterior_list <- getPosterior(   prior_list = prior_list,   mu_hat     = mu,   S_hat     = S_hat)  performBayesianMCP(posterior_list = posterior_list,                    contr          = contr_mat,                    crit_prob_adj  = critVal) #> Bayesian Multiple Comparison Procedure #> Summary: #>   Sign: 0  #>   Critical Probability: 0.97547  #>   Maximum Posterior Probability: 0.6446552  #>  #> Posterior Probabilities for Model Shapes: #>        Model Probability #>       linear   0.6191201 #>       linlog   0.6446552 #>        emax1   0.6412959 #>        emax2   0.6410572 #>  exponential   0.5839261"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":null,"dir":"Reference","previous_headings":"","what":"performBayesianMCPMod — performBayesianMCPMod","title":"performBayesianMCPMod — performBayesianMCPMod","text":"Performs Bayesian MCP Test step modeling combined fashion. See performBayesianMCP() function MCP Test step getModelFits() modeling step","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"performBayesianMCPMod — performBayesianMCPMod","text":"","code":"performBayesianMCPMod(   posterior_list,   contr,   crit_prob_adj,   simple = FALSE,   avg_fit = TRUE,   delta = NULL,   evidence_level = NULL,   med_selection = c(\"avgFit\", \"bestFit\"),   n_samples = 1000 )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"performBayesianMCPMod — performBayesianMCPMod","text":"posterior_list object class 'postList' created getPosterior() containing information (mixture) posterior distribution per dose group contr object class 'optContr' created getContr() function. contains contrast matrix used testing step. crit_prob_adj getCritProb object, specifying critical value used testing (probability scale). simple Boolean variable, defining whether simplified fit applied. Passed getModelFits() function. Default FALSE. avg_fit Boolean variable, defining whether average fit (based generalized AIC weights) performed addition individual models. Default TRUE. delta numeric value threshold Delta MED assessment. NULL, MED assessment performed. Default NULL. evidence_level numeric value 0 1 evidence level gamma MED assessment. required Bayesian MED assessment, see ?getMED details. Default NULL. med_selection string, either \"avgFit\" \"bestFit\", method MED selection. Default \"avgFit\". n_samples numerical number bootstrapped samples case Bayesian MED assessment performed. Default 1e3.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"performBayesianMCPMod — performBayesianMCPMod","text":"Bayesian MCP test result well modeling result.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/performBayesianMCPMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"performBayesianMCPMod — performBayesianMCPMod","text":"","code":"mods <- DoseFinding::Mods(linear      = NULL,                           linlog      = NULL,                           emax        = c(0.5, 1.2),                           exponential = 2,                           doses       = c(0, 0.5, 2,4, 8)) dose_levels  <- c(0, 0.5, 2, 4, 8) sd_posterior <- c(2.8, 3, 2.5, 3.5, 4) contr_mat <- getContr(   mods         = mods,   dose_levels  = dose_levels,   sd_posterior = sd_posterior) critVal <- getCritProb(   mods           = mods,   dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size   dose_levels    = dose_levels,   alpha_crit_val = 0.05) prior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),                    DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),                    DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,                    DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,                    DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2)) mu <- c(0, 1, 1.5, 2, 2.5) S_hat <- c(5, 4, 6, 7, 8) posterior_list <- getPosterior(   prior_list = prior_list,   mu_hat     = mu,   S_hat     = S_hat) performBayesianMCPMod(posterior_list = posterior_list,                       contr          = contr_mat,                       crit_prob_adj  = critVal,                       simple         = FALSE) #> Bayesian Multiple Comparison Procedure #> Summary: #>   Sign: 0  #>   Critical Probability: 0.9754201  #>   Maximum Posterior Probability: 0.6446552  #>  #> Posterior Probabilities for Model Shapes: #>        Model Probability #>       linear   0.6191201 #>       linlog   0.6446552 #>        emax1   0.6412959 #>        emax2   0.6410572 #>  exponential   0.5839261 #>"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"plot.modelFits — plot.modelFits","title":"plot.modelFits — plot.modelFits","text":"Plot function based ggplot2 package. Providing visualizations model average Fit. Black lines show fitted dose response models AIC based average model. Dots indicate posterior median vertical lines show corresponding credible intervals (.e. variability posterior distribution respective dose group). assess uncertainty model fit one can addition visualize credible bands (default coloring orange shaded areas). calculation bands performed via getBootstrapQuantiles() function. default setting credible bands calculated.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"plot.modelFits — plot.modelFits","text":"","code":"# S3 method for class 'modelFits' plot(   x,   gAIC = TRUE,   cr_intv = TRUE,   alpha_CrI = 0.05,   cr_bands = FALSE,   alpha_CrB = c(0.05, 0.5),   n_bs_smpl = 1000,   acc_color = \"orange\",   plot_res = 100,   ... )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"plot.modelFits — plot.modelFits","text":"x object type modelFits gAIC Logical value indicating whether gAIC values shown plot. Default TRUE cr_intv Logical value indicating whether credible intervals included plot. Default TRUE alpha_CrI Numerical value width credible intervals. Default set 0.05 (.e 95% CI shown). cr_bands Logical value indicating whether bootstrapped based credible bands shown plot. Default FALSE alpha_CrB Numerical vector width credible bands. Default set 0.05 0.5 (.e 95% CB 50% CB  shown). n_bs_smpl Number bootstrap samples used. Default 1000. acc_color Color credible bands. Default \"orange\". plot_res Number plotted doses within range dose levels, .e., resolution plot. Default 100. ... optional parameter passed plot().","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"plot.modelFits — plot.modelFits","text":"ggplot2 object","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/plot.modelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"plot.modelFits — plot.modelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models <- c(\"exponential\", \"linear\") dose_levels <- c(0, 1, 2, 4, 8) fit <- getModelFits(models      = models,                     posterior   = posterior_list,                     dose_levels = dose_levels,                     simple      = TRUE)  plot(fit)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":null,"dir":"Reference","previous_headings":"","what":"predict.modelFits — predict.modelFits","title":"predict.modelFits — predict.modelFits","text":"function performs model predictions based provided model dose specifications","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"predict.modelFits — predict.modelFits","text":"","code":"# S3 method for class 'modelFits' predict(object, doses = NULL, ...)"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"predict.modelFits — predict.modelFits","text":"object modelFits object containing information fitted model coefficients doses vector specifying doses prediction done ... Currently without function","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"predict.modelFits — predict.modelFits","text":"list model predictions specified models doses","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/predict.modelFits.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"predict.modelFits — predict.modelFits","text":"","code":"posterior_list <- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),                        DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),                        DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,                        DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,                        DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2)) models         <- c(\"emax\", \"exponential\", \"sigEmax\", \"linear\") dose_levels    <- c(0, 1, 2, 4, 8) fit            <- getModelFits(models      = models,                                posterior   = posterior_list,                                dose_levels = dose_levels)  predict(fit, doses = c(0, 1, 3, 4, 6, 8)) #> $emax #> [1] -0.008147777  2.977266585  5.136083687  5.647278697  6.271281080 #> [6]  6.637935274 #>  #> $exponential #> [1] 1.636554 2.207315 3.461645 4.150114 5.663125 7.377590 #>  #> $sigEmax #> [1] 0.00731386 2.89049046 5.22947029 5.72787171 6.28978958 6.59200716 #>  #> $linear #> [1] 1.419597 2.167297 3.662695 4.410394 5.905792 7.401191 #>  #> $avgFit #> [1] 0.2056172 2.8416974 4.9413358 5.4821866 6.2174408 6.7364367 #>  #> attr(,\"doses\") #> [1] 0 1 3 4 6 8"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":null,"dir":"Reference","previous_headings":"","what":"simulateData — simulateData","title":"simulateData — simulateData","text":"Function simulate patient level data normally distributed endpoint","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"simulateData — simulateData","text":"","code":"simulateData(   n_patients,   dose_levels,   sd,   mods,   n_sim = 1000,   true_model = NULL,   dr_means = NULL )"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"simulateData — simulateData","text":"n_patients Vector containing number patients numerical value per dose-group. dose_levels Vector containing different dosage levels. sd Standard deviation patient level. mods object class \"Mods\" specified DoseFinding package. n_sim Number simulations performed, Default 1000 true_model Default value NULL. Assumed true underlying model. Provided via String. e.g. \"emax\". case NULL, dose-response models, included mods input parameter used. dr_means vector, information assumed effects per dose group. Default NULL.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"simulateData — simulateData","text":"list object, containing patient level simulated data assumed true models. Also providing information simulation iteration, patient number well dosage levels.","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/reference/simulateData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"simulateData — simulateData","text":"","code":"models <- DoseFinding::Mods(linear      = NULL,                             linlog      = NULL,                             emax        = c(0.5, 1.2),                             exponential = 2,                              doses       = c(0, 0.5, 2,4, 8),                             maxEff      = 6) dose_levels <- c(0, 0.5, 2,4, 8) sd          <- 12 n_patients  <- c(40, 60, 60, 60, 60)  sim_data <- simulateData(n_patients  = n_patients,                          dose_levels = dose_levels,                          sd          = sd,                          mods        = models,                          n_sim       = 100)  head(sim_data) #>      simulation ptno dose    linear    linlog     emax1     emax2 exponential #> X0            1    1    0 -4.983620 -4.983620 -4.983620 -4.983620   -4.983620 #> X0.1          1    2    0 -1.628812 -1.628812 -1.628812 -1.628812   -1.628812 #> X0.2          1    3    0 11.511561 11.511561 11.511561 11.511561   11.511561 #> X0.3          1    4    0 -1.094049 -1.094049 -1.094049 -1.094049   -1.094049 #> X0.4          1    5    0 -6.499577 -6.499577 -6.499577 -6.499577   -6.499577 #> X0.6          1    6    0  4.134685  4.134685  4.134685  4.134685    4.134685"},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-102-06-feb-2025","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.2 (06-Feb-2025)","title":"BayesianMCPMod 1.0.2 (06-Feb-2025)","text":"CRAN release: 2025-02-06 Addition new vignette comparing frequentist Bayesian MCPMod using vague priors Extension getPosterior allow input fully populated variance-covariance matrix Added non-monotonic model shapes beta quadratic New argument assessDesign() skip Mod part Bayesian MCPMod Additional tests","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-101-03-apr-2024","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.1 (03-Apr-2024)","title":"BayesianMCPMod 1.0.1 (03-Apr-2024)","text":"CRAN release: 2024-04-05 Re-submission ‘BayesianMCPMod’ package Removed test occasionally failed fedora CRAN test system Fixed bug return wrong bootstrapped quantiles getBootstrapQuantiles() Added getBootstrapSamples(), separate function bootstrapping samples","code":""},{"path":"https://boehringer-ingelheim.github.io/BayesianMCPMod/news/index.html","id":"bayesianmcpmod-100-31-dec-2023","dir":"Changelog","previous_headings":"","what":"BayesianMCPMod 1.0.0 (31-Dec-2023)","title":"BayesianMCPMod 1.0.0 (31-Dec-2023)","text":"CRAN release: 2024-01-08 Initial release ‘BayesianMCPMod’ package Special thanks Jana Gierse, Bjoern Bornkamp, Chen Yao, Marius Thomas & Mitchell Thomann review valuable comments Thanks Kevin Kunzmann R infrastructure support Frank Fleischer methodological support","code":""}]
