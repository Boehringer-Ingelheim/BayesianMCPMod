---
title: "Vignette BayesianMCPMod - BayesianMCPMod Analysis"
subtitle: "WORK IN PROGRESS"
date: today
format: 
  html:
    fig-height: 3.5
    self-contained: true
    toc: true
    number-sections: true
    #bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Simulation Example of Bayesian MCPMod and MCPMod}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{quarto::html}
---

Following simulations will be conducted utilizing the BayesianMCPMod' package, with varying the expected effect for maximum dose and the sample sizes.


# Prior Specification
In a first step an uninformativ prior is calculated.

```{r}
uninf_prior_list <- list(
                   Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn")
                   
)
```

To calculate success probabilities for the different assumed dose-response models and the specified trial design we will apply the assessDesign function. 

## Minimal scnenario
### varying expected effect for maximum dose


```{r}

# list to store results
results_list_Bay_min <- list()


list_max_eff <- as.list(c(0.05,0.1,0.2,0.3,0.5))
chunks <- chunkVector(seq_along(list_max_eff), getDoParWorkers())


  
results_list_Bay_min <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
     min_models <- Mods(linear=NULL, 
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess, 
                     maxEff = list_max_eff[[i]],
                     direction = "increasing")
  #optimal contrasts
contM <- getContr(mods = min_models, 
                    dose_levels = doses.sim, 
                    prior_list = uninf_prior_list, 
                    dose_weights = c(1,1,1,1,1))

 # Simulation step
  success_probabilities_min <- assessDesign(
    n_patients  = Nsample,
    mods        = min_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha, 
    contr = contM) 
    
  })
  
}
  
results_min_Bay <- extract_success_rates(results_list_Bay_min, min_scenario)

minimal_Bay <- print_result_Bay_max_eff(results_min_Bay, c(min_scenario, "average"), expectedEffect)

minimal_Bay$kable_result



```
### varying sample size


```{r}
# Define the list of sample sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))

#optimal contrasts
#allocation c(1,1,1,1,1)
contM <- getContr(mods = min_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

#allocation c(2,1,1,1,2)
contM_2 <- getContr(mods = min_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(2,1,1,1,2))
contrasts_list = list(contM_2, contM, contM_2, contM)

# Initialize list to store results
results_list_nsample_min_Bay <- list()

#Models with maxEff = 0.2
min_models <- Mods(linear=NULL, 
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess, 
                     maxEff = expectedEffect_fix,
                     direction = "increasing")
  


chunks <- chunkVector(seq_along(nsample_list), getDoParWorkers())
  
results_list_nsample_min_Bay <- foreach(k = chunks, .combine = c, .export = c(as.character(min_models), as.character(contrasts_list)))  %dorng% {
  
  lapply(k, function (i) {
    
      success_probabilities_min <- assessDesign(
    n_patients  = nsample_list[[i]],
    mods        = min_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha, 
    contr = contrasts_list[[i]])
    
  })
}
  

results_min_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_min_Bay, min_scenario)
  
minimal_nsample_Bay <- print_result_Bay_nsample(results_min_Bay_nsample, c(min_scenario, "average"), nsample_vector)
minimal_nsample_Bay$kable_result



```



## Monotonic scenario
 
### varying expected effect for maximum dose

```{r}
results_list_Bay_monotonic <- list()




list_max_eff <- as.list(c(0.05,0.1,0.2,0.3,0.5))
chunks <- chunkVector(seq_along(list_max_eff), getDoParWorkers())


  
results_list_Bay_monotonic <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
    monotonic_models <- Mods(linear=NULL, 
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess, 
                         maxEff = list_max_eff[[i]],
                         direction = "increasing")
       
  # optimal contrasts
  contM <- getContr(mods = monotonic_models, 
                    dose_levels = doses.sim, 
                    prior_list = uninf_prior_list, 
                    dose_weights = c(1,1,1,1,1))
  
  # perform Simulations
  success_probabilities_monotonic <- assessDesign(
    n_patients  = Nsample,
    mods        = monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha, 
    contr = contM)
    

    
  })
  
}
  

##power results in vector for tables
results_monotonic_Bay <- extract_success_rates(results_list_Bay_monotonic, monotonic_scenario)


monotonic_Bay <- print_result_Bay_max_eff(results_monotonic_Bay, c(monotonic_scenario, "average"), expectedEffect)
  

monotonic_Bay$kable_result



```

### varying sample size
```{r}
# Initialize list to store results
results_list_nsample_monotonic_Bay <- list()

# dose - response models
monotonic_models <- Mods(linear=NULL, 
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess, 
                         maxEff = expectedEffect_fix,
                         direction = "increasing")
 
#optimal contrasts
#allocation c(1,1,1,1,1)
contM <- getContr(mods = monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

#allocation c(2,1,1,1,2)
contM_2 <- getContr(mods = monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(2,1,1,1,2))
contrasts_list = list(contM_2, contM, contM_2, contM)


chunks <- chunkVector(seq_along(nsample_list), getDoParWorkers())
  
results_list_nsample_monotonic_Bay <- foreach(k = chunks, .combine = c, .export = c(as.character(monotonic_models), as.character(contrasts_list)))  %dorng% {
  
  lapply(k, function (i) {
    
    success_probabilities_monotonic <- assessDesign(
    n_patients  = nsample_list[[i]],
    mods        = monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha,
    contr = contrasts_list[[i]])
  })
}
  

results_monotonic_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_monotonic_Bay, monotonic_scenario)


monotonic_nsample_Bay <- print_result_Bay_nsample(results_monotonic_Bay_nsample, c(monotonic_scenario, "average"), nsample_vector)
monotonic_nsample_Bay$kable_result


```


## Non-monotonic scenario
### varying expected effect for maximum dose
```{r}
results_list_Bay_non_monotonic <- list()


list_max_eff <- as.list(c(0.05,0.1,0.2,0.3,0.5))
chunks <- chunkVector(seq_along(list_max_eff), getDoParWorkers())


  
results_list_Bay_non_monotonic <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
    
     non_monotonic_models <- Mods(linear=NULL, 
                               emax = emax.g,
                               sigEmax = sigEmax.g,
                               quadratic = quad.g,
                               betaMod = beta.g,
                               doses = doses.sim,
                               placEff = plc.guess,
                               maxEff = list_max_eff[[i]],
                               direction = "increasing",
                               addArgs = list(scal=9.6))

  #optimal contrasts
  contM <- getContr(mods = non_monotonic_models,
                    dose_levels = doses.sim,
                    prior_list = uninf_prior_list,
                    dose_weights = c(1,1,1,1,1))

  success_probabilities_non_monotonic <- assessDesign(
    n_patients  = Nsample,
    mods        = non_monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha,
    contr = contM)


  })
  
}
  
results_non_monotonic_Bay <- extract_success_rates(results_list_Bay_non_monotonic, non_monotonic_scenario)

non_monotonic_Bay <- print_result_Bay_max_eff(results_non_monotonic_Bay, c(non_monotonic_scenario, "average"), expectedEffect)
  
non_monotonic_Bay$kable_result


```
### varying sample size
```{r}
# Initialize list to store results
results_list_nsample_non_monotonic_Bay <- list()

non_monotonic_models <- Mods(linear=NULL, 
                             emax = emax.g,
                             sigEmax = sigEmax.g,
                             quadratic = quad.g,
                             betaMod = beta.g,
                             doses = doses.sim,
                             placEff = plc.guess, 
                             maxEff = expectedEffect_fix,
                             direction = "increasing",
                             addArgs = list(scal=9.6))
 
  #optimal contrasts
contM <- getContr(mods = non_monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

contM_2 <- getContr(mods = non_monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(2,1,1,1,2))

contrasts_list = list(contM_2, contM, contM_2, contM)
  


chunks <- chunkVector(seq_along(nsample_list), getDoParWorkers())
  
results_list_nsample_non_monotonic_Bay <- foreach(k = chunks, .combine = c, .export = c(as.character(non_monotonic_models), as.character(contrasts_list)))  %dorng% {
  
  lapply(k, function (i) {
    
    success_probabilities_non_monotonic <- assessDesign(
    n_patients  = nsample_list[[i]],
    mods        = non_monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha,
    contr = contrasts_list[[i]])
  })
}
  

results_non_monotonic_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_non_monotonic_Bay, non_monotonic_scenario)


non_monotonic_nsample_Bay <- print_result_Bay_nsample(results_non_monotonic_Bay_nsample, c(non_monotonic_scenario, "average"), nsample_vector)
non_monotonic_nsample_Bay$kable_result


```


## Variability scenario
### varying expected effect for maximum dose
```{r}

# prior 
var_uninf_prior_list <- list(
                   Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"))

results_list_Bay_var <- list()



list_max_eff <- as.list(c(0.05,0.1,0.2,0.3,0.5))
chunks <- chunkVector(seq_along(list_max_eff), getDoParWorkers())


  
results_list_Bay_var <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
      var_models <- Mods(linear = NULL, 
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses_var,
                     placEff = plc.guess,
                     maxEff = list_max_eff[[i]],
                     direction = "increasing")

  contM <- getContr(mods = var_models,
                    dose_levels = doses_var,
                    prior_list = var_uninf_prior_list,
                    dose_weights = c(1,1,1,1))

  success_probabilities_var <- assessDesign(
    n_patients  = Nsample_var,
    mods        = var_models,
    prior_list  = var_uninf_prior_list,
    sd          = sd.sim_var,
    n_sim       = n_sim,
    alpha_crit_val = alpha,
    contr = contM)

  })
  
}


results_variability_Bay <- extract_success_rates(results_list_Bay_var, variability_scenario)

variability_Bay <- print_result_Bay_max_eff(results_variability_Bay, c(variability_scenario, "average"), expectedEffect)

variability_Bay$kable_result


```
### varying sample size
```{r}
results_list_nsample_Bay_var <- list()

var_models <- Mods(linear=NULL,
                   exponential = exp.g,
                   emax = emax.g,
                   doses = doses_var,
                   placEff = plc.guess, 
                   maxEff = expectedEffect_fix,
                   direction = "increasing")

#optimal contrasts
contM <- getContr(mods = var_models, 
                  dose_levels = doses_var, 
                  prior_list = var_uninf_prior_list, 
                  dose_weights = c(1,1,1,1))

contM_2 <- getContr(mods = var_models, 
                  dose_levels = doses_var, 
                  prior_list = var_uninf_prior_list, 
                  dose_weights = c(2,1,1,2))
contrasts_list = list(contM_2, contM, contM_2, contM)


nsample_list_var <- list(20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1))

chunks <- chunkVector(seq_along(nsample_list_var), getDoParWorkers())
  
results_list_nsample_Bay_var <- foreach(k = chunks, .combine = c, .export = c(as.character(var_models), as.character(contrasts_list)))  %dorng% {
  
  lapply(k, function (i) {
    success_probabilities_var <- assessDesign(
    n_patients  = nsample_list_var[[i]],
    mods        = var_models,
    prior_list  = var_uninf_prior_list,
    sd          = sd.sim_var,
    n_sim       = n_sim,
    alpha_crit_val = alpha,
    contr = contrasts_list[[i]])
   
  })
}
  

results_variability_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_Bay_var, variability_scenario)


var_nsample_Bay <-  print_result_Bay_nsample(results_variability_Bay_nsample, c(variability_scenario, "average"), as.vector(nsample_list_var))
var_nsample_Bay$kable_result


```