---
title: "Vignette BayesianMCPMod - convergence of power values"
subtitle: "WORK IN PROGRESS"
date: today
format: 
  html:
    fig-height: 3.5
    self-contained: true
    toc: true
    number-sections: true
    #bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Simulation Example of Bayesian MCPMod and MCPMod}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{quarto::html}
---

### minimal BayesianMCPMod
```{r}


# Define a vector of different n_sim values
n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000))
n_sim_values <- c(100, 500, 1000, 2500, 5000, 10000)

# Initialize a list to store the results
results_list_nsim_Bay <- list()

min_models <- Mods(linear=NULL,
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess,
                     maxEff = expectedEffect_fix,
                     direction = "increasing")
#optimal contrasts
contM <- getContr(mods = min_models,
                    dose_levels = doses.sim,
                    prior_list = uninf_prior_list,
                    dose_weights = c(1,1,1,1,1))

chunks <- chunkVector(seq_along(n_sim_values_list), getDoParWorkers())

  
results_list_nsim_Bay <- foreach(k = chunks, .combine = c, .export = c(as.character(min_models), as.character(contM))) %dorng% {

  lapply(k, function (i) {


 # Simulation step
  success_probabilities_min <- assessDesign(
    n_patients  = Nsample,
    mods        = min_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim_values_list[[i]],
    alpha_crit_val = alpha,
    contr = contM)

  })

}

results_nsim_Bay <- extract_success_rates_nsim(results_list_nsim_Bay, min_scenario, n_sim_values)


```

### minimal MCPModPack
```{r warning=FALSE}


# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)




list_models <- list(sim_models_min_linear, sim_models_min_linear, sim_models_min_linear, sim_models_min_linear, sim_models_min_linear, sim_models_min_linear,
                    sim_models_min_exp, sim_models_min_exp, sim_models_min_exp, sim_models_min_exp, sim_models_min_exp, sim_models_min_exp, 
                    sim_models_min_emax, sim_models_min_emax, sim_models_min_emax, sim_models_min_emax, sim_models_min_emax, sim_models_min_emax)
n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000, 
                               100, 500, 1000, 2500, 5000, 10000, 
                               100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_nsim_MCP <- foreach(k = chunks, .combine = c, .export = c(as.character(min_modelsPack)))  %dorng% {
  
  lapply(k, function (i) {
    # Simulation parameters
  sim_parameters = list(n = Nsample,
                      doses = doses.sim,
                      dropout_rate = 0.0,
                      go_threshold = 0.1,
                      nsims = n_sim_values_list[[i]])
    
    func_sim(min_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}



```



### monotonic BayesianMCPMod
```{r}


# Initialize a list to store the results
 results_list_nsim_Bay_monotonic <- list()
 
monotonic_models <- Mods(linear=NULL,
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess,
                         maxEff = expectedEffect_fix,
                         direction = "increasing")

#optimal contrasts
contM <- getContr(mods = monotonic_models,
                  dose_levels = doses.sim,
                  prior_list = uninf_prior_list,
                  dose_weights = c(1,1,1,1,1))

n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(n_sim_values_list), getDoParWorkers())


results_list_nsim_Bay_monotonic <- foreach(k = chunks, .combine = c, .export = c(as.character(monotonic_models), as.character(contM))) %dorng% {

  lapply(k, function (i) {


 # Simulation step
  success_probabilities_monotonic <- assessDesign(
    n_patients  = Nsample,
    mods        = monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim_values_list[[i]],
    alpha_crit_val = alpha,
    contr = contM)

  })

}



results_nsim_Bay_monotonic <- extract_success_rates_nsim(results_list_nsim_Bay_monotonic, monotonic_scenario, n_sim_values)

```

### monotonic MCPModPack

```{r warning=FALSE}


sim_models_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_monotonic_exp$max_effect <- expectedEffect_fix
sim_models_monotonic_emax$max_effect <- expectedEffect_fix
sim_models_monotonic_logistic$max_effect <- expectedEffect_fix
sim_models_monotonic_sigemax$max_effect <- expectedEffect_fix

list_models <- list(sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear, 
                    sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp, 
                    sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax,
                    sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic,
                    sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax
                    )
n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_nsim_MCP_monotonic <- foreach(k = chunks, .combine = c, .export = c(as.character(monotonic_modelsPack)))  %dorng% {
  
  lapply(k, function (i) {
    # Simulation parameters
  sim_parameters = list(n = Nsample,
                      doses = doses.sim,
                      dropout_rate = 0.0,
                      go_threshold = 0.1,
                      nsims = n_sim_values_list[[i]])
    
    func_sim(monotonic_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}


```

### non-monotonic BayesianMCPMod

```{r}


# Initialize list to store results
results_list_nsim_Bay_non_monotonic <- list()

non_monotonic_models <- Mods(linear=NULL,
                             emax = emax.g,
                             sigEmax = sigEmax.g,
                             quadratic = quad.g,
                             betaMod = beta.g,
                             doses = doses.sim,
                             placEff = plc.guess,
                             maxEff = expectedEffect_fix,
                             direction = "increasing",
                             addArgs = list(scal=9.6))

  #optimal contrasts
contM <- getContr(mods = non_monotonic_models,
                  dose_levels = doses.sim,
                  prior_list = uninf_prior_list,
                  dose_weights = c(1,1,1,1,1))

n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(n_sim_values_list), getDoParWorkers())


results_list_nsim_Bay_non_monotonic <- foreach(k = chunks, .combine = c, .export = c(as.character(non_monotonic_models), as.character(contM))) %dorng% {

  lapply(k, function (i) {


 # Simulation step
  success_probabilities_non_monotonic <- assessDesign(
    n_patients  = Nsample,
    mods        = non_monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim_values_list[[i]],
    alpha_crit_val = alpha,
    contr = contM)

  })

}



results_nsim_Bay_non_monotonic <- extract_success_rates_nsim(results_list_nsim_Bay_non_monotonic, non_monotonic_scenario, n_sim_values)
```

### non-monotonic MCPModPack


```{r}
# linear with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(linear = NULL)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
results_nsim_non_monotonic_linear <- result$linear


```

```{r}
# emax with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(emax = 0.6666667)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
results_nsim_non_monotonic_emax <- result$`emax (ED50=0.6666667)`
```


```{r}
# sigemax with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(sigEmax = rbind(c(1.528629, 4.087463)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
results_nsim_non_monotonic_sigemax <- result$`sigEmax (ED50=1.528629,h=4.087463)`

```
```{r}
#quadratic with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(quadratic = -0.09688711)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)

results_nsim_non_monotonic_quadratic <- result$`quadratic (delta=-0.09688711)`

```

```{r}
# beta with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(betaMod = rbind(c(1.396434, 1.040978)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
results_nsim_non_monotonic_beta <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`

```
```{r}
results_nsim_MCP_non_monotonic <- data.table(
  linear = results_nsim_non_monotonic_linear,
  emax = results_nsim_non_monotonic_emax,
  sigemax = results_nsim_non_monotonic_sigemax,
  quadratic = results_nsim_non_monotonic_quadratic,
  beta = results_nsim_non_monotonic_beta
)
```




### variability BayesianMCPMod
```{r}


# Initialize list to store results
results_list_nsim_Bay_var <- list()

var_models <- Mods(linear=NULL,
                   exponential = exp.g,
                   emax = emax.g,
                   doses = doses_var,
                   placEff = plc.guess,
                   maxEff = expectedEffect_fix,
                   direction = "increasing")

contM <- getContr(mods = var_models,
                  dose_levels = doses_var,
                  prior_list = var_uninf_prior_list,
                  dose_weights = c(1,1,1,1))

n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(n_sim_values_list), getDoParWorkers())


results_list_nsim_Bay_var <- foreach(k = chunks, .combine = c, .export = c(as.character(var_models), as.character(contM))) %dorng% {

  lapply(k, function (i) {


 # Simulation step
  success_probabilities_var <- assessDesign(
    n_patients  = Nsample_var,
    mods        = var_models,
    prior_list  = var_uninf_prior_list,
    sd          = sd.sim_var,
    n_sim       = n_sim_values_list[[i]],
    alpha_crit_val = alpha,
    contr = contM)

  })

}



results_nsim_Bay_var <- extract_success_rates_nsim(results_list_nsim_Bay_var, variability_scenario, n_sim_values)
```


### variability MCPModPack
```{r, warning=FALSE}


results_list_nsim_MCP_var = list(
  power_var_nsim_linear = vector(),
  power_var_nsim_exp = vector(),
  power_var_nsim_emax= vector())

# assume maximum effect = 0.2
sim_models_var_linear$max_effect <- expectedEffect_fix
sim_models_var_exp$max_effect <- expectedEffect_fix
sim_models_var_emax$max_effect <- expectedEffect_fix

sim_parameters_var$n <- Nsample_var


list_models <- list(sim_models_var_linear, sim_models_var_linear, sim_models_var_linear, sim_models_var_linear, sim_models_var_linear, sim_models_var_linear,
                    sim_models_var_exp, sim_models_var_exp, sim_models_var_exp, sim_models_var_exp, sim_models_var_exp, sim_models_var_exp,
                    sim_models_var_emax, sim_models_var_emax, sim_models_var_emax, sim_models_var_emax, sim_models_var_emax, sim_models_var_emax)
n_sim_values_list <- as.list(c(100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000,
                               100, 500, 1000, 2500, 5000, 10000))

chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_nsim_MCP_var <- foreach(k = chunks, .combine = c, .export = c(as.character(var_modelsPack)))  %dorng% {
  
  lapply(k, function (i) {
    # Simulation parameters
  sim_parameters = list(n = Nsample_var,
                      doses = doses_var,
                      dropout_rate = 0.0,
                      go_threshold = 0.1,
                      nsims = n_sim_values_list[[i]])
    
    func_sim(var_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}


```