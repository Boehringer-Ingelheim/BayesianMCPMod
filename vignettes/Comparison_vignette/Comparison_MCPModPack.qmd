```{r}
knitr::opts_chunk$set(eval = FALSE)
```

Following simulations will be conducted utilizing the MCPModPack package, with varying the expected effect for maximum dose and the sample sizes.

## Minimal scenario

### varying expected effect for maximum dose
```{r warning=FALSE}
# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                             exponential = 4.447149,
                             max_effect = c(0.05,0.1,0.2,0.3,0.5),
                             sd = rep(sd.sim, length(doses.sim)),
                             placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)

# Initialize list to store results
results_list_min <- list()
  
# Run simulation
func_sim <- function(models ,sim_models, sim_parameters){

sim_result = MCPModSimulation(endpoint_type = "Normal", 
                                 models = models, 
                                 alpha = alpha, 
                                 direction = "increasing", 
                                 model_selection = "aveAIC", 
                                 Delta = 0.1,
                                 sim_models = sim_models,
                                 sim_parameters = sim_parameters)
}


list_models <- list(sim_models_min_linear, sim_models_min_exp, sim_models_min_emax)
chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_min <- foreach(k = chunks, .combine = c)  %dorng% {
  
  lapply(k, function (i) {
    
    func_sim(min_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}




#store results
results_min_MCP <- data.table(
  max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  linear = c(results_list_min[[1]]$sim_results$power),
  exponential = c(results_list_min[[2]]$sim_results$power),
  emax = c(results_list_min[[3]]$sim_results$power),
  Average = c(sum(results_list_min[[1]]$sim_results$power[1], results_list_min[[2]]$sim_results$power[1], results_list_min[[3]]$sim_results$power[1])/3,
               sum(results_list_min[[1]]$sim_results$power[2], results_list_min[[2]]$sim_results$power[2], results_list_min[[3]]$sim_results$power[2])/3,
               sum(results_list_min[[1]]$sim_results$power[3], results_list_min[[2]]$sim_results$power[3], results_list_min[[3]]$sim_results$power[3])/3,
               sum(results_list_min[[1]]$sim_results$power[4], results_list_min[[2]]$sim_results$power[4], results_list_min[[3]]$sim_results$power[4])/3,
               sum(results_list_min[[1]]$sim_results$power[5], results_list_min[[2]]$sim_results$power[5], results_list_min[[3]]$sim_results$power[5])/3))


kable(results_min_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects " = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Minimal scenario " = 5), font_size = 15, bold = TRUE)
    


```

### varying sample size
```{r warning=FALSE}
#list of different samole sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))

# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)


# store results
power_min_nsample_linear <- vector()
power_min_nsample_exp <- vector()
power_min_nsample_emax <- vector()





# # Loop over nsample values
# for (i in seq_along(nsample_list)) {
#   
#   # Update nsample in simulation parameters
#   sim_parameters$n <- nsample_list[[i]]
#   
#   # Set max_effect to 0.2
#   min_modelsPack$max_effect <- expectedEffect_fix
#   
#   # power values for different assumed true models
#   power_nsample_linear <- func_sim(min_modelsPack, sim_models_min_linear, sim_parameters)
#   power_min_nsample_linear[i] <- power_nsample_linear$sim_results$power
#   
#   power_nsample_exp <- func_sim(min_modelsPack, sim_models_min_exp, sim_parameters)
#   power_min_nsample_exp[i] <-power_nsample_exp$sim_results$power
#   
#   power_nsample_emax <- func_sim(min_modelsPack, sim_models_min_emax, sim_parameters)
#   power_min_nsample_emax[i] <- power_nsample_exp$sim_results$power
#   
# }
# Set max_effect to 0.2
min_modelsPack$max_effect <- expectedEffect_fix
#list of different samole sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))

list_models <- list(sim_models_min_linear,sim_models_min_linear,sim_models_min_linear,sim_models_min_linear,
                    sim_models_min_exp, sim_models_min_exp,sim_models_min_exp,sim_models_min_exp,
                    sim_models_min_emax, sim_models_min_emax, sim_models_min_emax, sim_models_min_emax)

#ind_tasks <- 1:12

chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_min_nsample <- foreach(k = chunks, .combine = c, .export = c(as.character(min_modelsPack), as.character(nsample_list)))  %dorng% {
  lapply(k, function (i) {
    sim_parameters = list(n = nsample_list[[i]], 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)
    
    func_sim(min_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}

# store results
results_min_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = c(results_list_min_nsample[[1]]$sim_results$power, results_list_min_nsample[[2]]$sim_results$power, results_list_min_nsample[[3]]$sim_results$power, results_list_min_nsample[[4]]$sim_results$power),
  Exponential = c(results_list_min_nsample[[5]]$sim_results$power, results_list_min_nsample[[6]]$sim_results$power, results_list_min_nsample[[7]]$sim_results$power, results_list_min_nsample[[8]]$sim_results$power),
  Emax = c(results_list_min_nsample[[9]]$sim_results$power, results_list_min_nsample[[10]]$sim_results$power, results_list_min_nsample[[11]]$sim_results$power, results_list_min_nsample[[12]]$sim_results$power),
  Average = c(sum(results_list_min_nsample[[1]]$sim_results$power, results_list_min_nsample[[5]]$sim_results$power, results_list_min_nsample[[9]]$sim_results$power)/3,
              sum(results_list_min_nsample[[2]]$sim_results$power, results_list_min_nsample[[6]]$sim_results$power, results_list_min_nsample[[10]]$sim_results$power)/3,
              sum(results_list_min_nsample[[3]]$sim_results$power, results_list_min_nsample[[7]]$sim_results$power, results_list_min_nsample[[11]]$sim_results$power)/3,
              sum(results_list_min_nsample[[4]]$sim_results$power, results_list_min_nsample[[8]]$sim_results$power, results_list_min_nsample[[12]]$sim_results$power)/3)
)

kable(results_min_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes " = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Minimal scenario " = 5), font_size = 15, bold = TRUE)
    


```

## Monotonic scenario

### varying expected effect for maximum dose
```{r warning=FALSE}
# assumed dose - response models
sim_models_monotonic_linear = list(linear = NA,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_exp = list( exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_logistic = list(logistic = c(1.5, 0.2275598),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_sigemax= list(sigemax =  c(1.528629, 4.087463),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_emax= list(emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)

# Initialize list to store results
results_list_monotonic <- list()

list_models <- list(sim_models_monotonic_linear, sim_models_monotonic_exp, sim_models_monotonic_emax, sim_models_monotonic_logistic, sim_models_monotonic_sigemax)
chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_monotonic <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
    func_sim(monotonic_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}
  

results_monotonic_MCP <- data.table(
  max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  linear = c(results_list_monotonic[[1]]$sim_results$power),
  exp = c(results_list_monotonic[[2]]$sim_results$power),
  emax = c(results_list_monotonic[[3]]$sim_results$power),
  logistic = c(results_list_monotonic[[4]]$sim_results$power),
  sigEmax = c(results_list_monotonic[[5]]$sim_results$power),
  Average = c((sum(results_list_monotonic[[1]]$sim_results$power[1], results_list_monotonic[[2]]$sim_results$power[1], results_list_monotonic[[3]]$sim_results$power[1], results_list_monotonic[[4]]$sim_results$power[1], results_list_monotonic[[5]]$sim_results$power[1])/5),
  (sum(results_list_monotonic[[1]]$sim_results$power[2], results_list_monotonic[[2]]$sim_results$power[2], results_list_monotonic[[3]]$sim_results$power[2], results_list_monotonic[[4]]$sim_results$power[2], results_list_monotonic[[5]]$sim_results$power[2])/5),
              (sum(results_list_monotonic[[1]]$sim_results$power[3], results_list_monotonic[[2]]$sim_results$power[3], results_list_monotonic[[3]]$sim_results$power[3], results_list_monotonic[[4]]$sim_results$power[3], results_list_monotonic[[5]]$sim_results$power[3])/5),
(sum(results_list_monotonic[[1]]$sim_results$power[4], results_list_monotonic[[2]]$sim_results$power[4], results_list_monotonic[[3]]$sim_results$power[4], results_list_monotonic[[4]]$sim_results$power[4], results_list_monotonic[[5]]$sim_results$power[4])/5),
(sum(results_list_monotonic[[1]]$sim_results$power[5], results_list_monotonic[[2]]$sim_results$power[5], results_list_monotonic[[3]]$sim_results$power[5], results_list_monotonic[[4]]$sim_results$power[5], results_list_monotonic[[5]]$sim_results$power[5])/5))
)

kable(results_monotonic_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects " = 7), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Monotonic scenario " = 7), font_size = 15, bold = TRUE)
    

```

### varying sample size
```{r warning=FALSE}
# assumed dose- response model with assumed maximum effect = 0.2
sim_models_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_monotonic_exp$max_effect <- expectedEffect_fix
sim_models_monotonic_emax$max_effect <- expectedEffect_fix
sim_models_monotonic_logistic$max_effect <- expectedEffect_fix
sim_models_monotonic_sigemax$max_effect <- expectedEffect_fix

# store results
power_monotonic_nsample_linear <- vector()
power_monotonic_nsample_exp <- vector()
power_monotonic_nsample_emax <- vector()
power_monotonic_nsample_logistic <- vector()
power_monotonic_nsample_sigemax <- vector()



# Set max_effect to 0.2
monotonic_modelsPack$max_effect <- expectedEffect_fix
#list of different samole sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1),
                    20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))

list_models <- list(sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear, sim_models_monotonic_linear,
                    sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp, sim_models_monotonic_exp,
                    sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax, sim_models_monotonic_emax,
                    sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic, sim_models_monotonic_logistic,
                    sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax, sim_models_monotonic_sigemax)


chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_monotonic_nsample <- foreach(k = chunks, .combine = c, .export = c(as.character(monotonic_modelsPack), as.character(nsample_list)))  %dorng% {
  lapply(k, function (i) {
    sim_parameters = list(n = nsample_list[[i]], 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)
    
    func_sim(monotonic_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}


# store results
results_monotonic_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = c(results_list_monotonic_nsample[[1]]$sim_results$power, results_list_monotonic_nsample[[2]]$sim_results$power, results_list_monotonic_nsample[[3]]$sim_results$power, results_list_monotonic_nsample[[4]]$sim_results$power),
  Exponential = c(results_list_monotonic_nsample[[5]]$sim_results$power, results_list_monotonic_nsample[[6]]$sim_results$power, results_list_monotonic_nsample[[7]]$sim_results$power, results_list_monotonic_nsample[[8]]$sim_results$power),
  Emax = c(results_list_monotonic_nsample[[9]]$sim_results$power, results_list_monotonic_nsample[[10]]$sim_results$power, results_list_monotonic_nsample[[11]]$sim_results$power, results_list_monotonic_nsample[[12]]$sim_results$power),
  Logistic = c(results_list_monotonic_nsample[[13]]$sim_results$power, results_list_monotonic_nsample[[14]]$sim_results$power, results_list_monotonic_nsample[[15]]$sim_results$power, results_list_monotonic_nsample[[16]]$sim_results$power),
  sigEmax = c(results_list_monotonic_nsample[[17]]$sim_results$power, results_list_monotonic_nsample[[18]]$sim_results$power, results_list_monotonic_nsample[[19]]$sim_results$power, results_list_monotonic_nsample[[20]]$sim_results$power),
Average = c((sum(results_list_monotonic_nsample[[1]]$sim_results$power, results_list_monotonic_nsample[[5]]$sim_results$power, results_list_monotonic_nsample[[9]]$sim_results$power, ... =   results_list_monotonic_nsample[[13]]$sim_results$power, results_list_monotonic_nsample[[17]]$sim_results$power)/5),
              (sum(results_list_monotonic_nsample[[2]]$sim_results$power, results_list_monotonic_nsample[[6]]$sim_results$power, results_list_monotonic_nsample[[10]]$sim_results$power, results_list_monotonic_nsample[[14]]$sim_results$power, results_list_monotonic_nsample[[18]]$sim_results$power)/5),
            (sum(results_list_monotonic_nsample[[3]]$sim_results$power, results_list_monotonic_nsample[[7]]$sim_results$power, results_list_monotonic_nsample[[11]]$sim_results$power, results_list_monotonic_nsample[[15]]$sim_results$power, results_list_monotonic_nsample[[19]]$sim_results$power)/5),
            (sum(results_list_monotonic_nsample[[4]]$sim_results$power, results_list_monotonic_nsample[[8]]$sim_results$power, results_list_monotonic_nsample[[12]]$sim_results$power, results_list_monotonic_nsample[[16]]$sim_results$power, results_list_monotonic_nsample[[20]]$sim_results$power)/5)))


kable(results_monotonic_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 7), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Monotonic scenario" = 7), font_size = 15, bold = TRUE)
    

```

## Non-monotonic scenario

### varying expected effect for maximum dose

For the simulations of the non-monotonic scenario, the R package 'Dosefinding' was used instead of 'MCPModPack

```{r}
# linear with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(linear = NULL)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.05,0.1,0.2,0.3,0.5), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_linear <- result$linear
```


```{r}
# emax with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(emax = 0.6666667)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.05,0.1,0.2,0.3,0.5), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_emax <- result$`emax (ED50=0.6666667)`
```


```{r}
# sigemax with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(sigEmax = rbind(c(1.528629, 4.087463)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.05,0.1,0.2,0.3,0.5), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_sigemax <- result$`sigEmax (ED50=1.528629,h=4.087463)`
```



```{r}
#quadratic with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(quadratic = -0.09688711)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.05,0.1,0.2,0.3,0.5), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_quadratic <- result$`quadratic (delta=-0.09688711)`

```

```{r}
# beta with DoseFinding package
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(betaMod = rbind(c(1.396434, 1.040978)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.05,0.1,0.2,0.3,0.5), sd = c(0.4), n_total = c(200))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_beta <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`
```


```{r}
#linear, emax, sigemax, quadratic
results_non_monotonic_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  linear = power_non_monotonic_linear,
  emax = power_non_monotonic_emax,
  sigEmax = power_non_monotonic_sigemax,
  quadratic = power_non_monotonic_quadratic,
  beta = power_non_monotonic_beta,
  average = c((sum(power_non_monotonic_linear[1],power_non_monotonic_emax[1], power_non_monotonic_sigemax[1], power_non_monotonic_quadratic[1], power_non_monotonic_beta[1])/5),
    (sum(power_non_monotonic_linear[2],power_non_monotonic_emax[2], power_non_monotonic_sigemax[2], power_non_monotonic_quadratic[2], power_non_monotonic_beta[2])/5),
    (sum(power_non_monotonic_linear[3],power_non_monotonic_emax[3], power_non_monotonic_sigemax[3], power_non_monotonic_quadratic[3], power_non_monotonic_beta[3])/5),
    (sum(power_non_monotonic_linear[4],power_non_monotonic_emax[4], power_non_monotonic_sigemax[4], power_non_monotonic_quadratic[4], power_non_monotonic_beta[4])/5),
    (sum(power_non_monotonic_linear[5],power_non_monotonic_emax[5], power_non_monotonic_sigemax[5], power_non_monotonic_quadratic[5], power_non_monotonic_beta[5])/5))
  )


kable(results_non_monotonic_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects" = 7), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Non-monotonic scenario" = 7), font_size = 15, bold = TRUE)
```

### varying sample size

```{r warning=FALSE}


# store results
power_non_monotonic_nsample_linear <- vector()
power_non_monotonic_nsample_emax <- vector()
power_non_monotonic_nsample_quadratic <- vector()
power_non_monotonic_nsample_sigemax <- vector()
power_non_monotonic_nsample_beta <- vector()


```

```{r}
# linear with DoseFinding
# allocation = c(1,1,1,1,1)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(linear = NULL)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(150,180))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_linear[2] <- result$linear[1]
power_non_monotonic_nsample_linear[4] <- result$linear[2]

# allocation = c(2,1,1,1,2)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(2,1,1,1,2)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(linear = NULL)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(140,168))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_linear[1] <- result$linear[1]
power_non_monotonic_nsample_linear[3] <- result$linear[2]
```


```{r}

# emax with DoseFinding
#allocation = c(1,1,1,1,1)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(emax = 0.6666667)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(150,180))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_emax[2] <- result$`emax (ED50=0.6666667)`[1]
power_non_monotonic_nsample_emax[4] <- result$`emax (ED50=0.6666667)`[2]

# allocation = c(2,1,1,1,2)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(2,1,1,1,2)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(emax = 0.6666667)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(140,168))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_emax[1] <- result$`emax (ED50=0.6666667)`[1]
power_non_monotonic_nsample_emax[3] <- result$`emax (ED50=0.6666667)`[2]
```



```{r}
# sigemax with DoseFinding
#allocation = c(1,1,1,1,1)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(sigEmax = rbind(c(1.528629, 4.087463)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(150,180))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_sigemax[2] <- result$`sigEmax (ED50=1.528629,h=4.087463)`[1]
power_non_monotonic_nsample_sigemax[4] <- result$`sigEmax (ED50=1.528629,h=4.087463)`[2]

# allocation = c(2,1,1,1,2)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(2,1,1,1,2)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(sigEmax = rbind(c(1.528629, 4.087463)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(140,168))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_sigemax[1] <- result$`sigEmax (ED50=1.528629,h=4.087463)`[1]
power_non_monotonic_nsample_sigemax[3] <- result$`sigEmax (ED50=1.528629,h=4.087463)`[2]
```




```{r}
# quadratic with DoseFinding
#allocation = c(1,1,1,1,1)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(quadratic = -0.09688711)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(150,180))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_quadratic[2] <- result$`quadratic (delta=-0.09688711)`[1]
power_non_monotonic_nsample_quadratic[4] <- result$`quadratic (delta=-0.09688711)`[2]

# allocation = c(2,1,1,1,2)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(2,1,1,1,2)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(quadratic = -0.09688711)
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(140,168))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_quadratic[1] <- result$`quadratic (delta=-0.09688711)`[1]
power_non_monotonic_nsample_quadratic[3] <- result$`quadratic (delta=-0.09688711)`[2]
```



```{r}
# beta with DoseFinding
#allocation = c(1,1,1,1,1)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(1,1,1,1,1)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(betaMod = rbind(c(1.396434, 1.040978)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(150,180))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_beta[2] <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`[1]
power_non_monotonic_nsample_beta[4] <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`[2]

# allocation = c(2,1,1,1,2)
mvt_control <- mvtnorm.control(maxpts = 30000, abseps = 0.001, releps = 0)
doses <- c(0,1,2,4,8)
allocation <- c(2,1,1,1,2)
alpha <- 0.05
addArgs <- list(off = 0.08, scal = 9.6)

resp_mod_list <- list(betaMod = rbind(c(1.396434, 1.040978)))
cand_mod_list <- list(linear = NULL, emax = 0.6666667, quadratic = -0.09688711, betaMod = rbind(c(1.396434, 1.040978)), sigEmax = rbind(c(1.528629, 4.087463)))
mods <- do.call(Mods, append(cand_mod_list, 
        list(maxEff = 1, doses = doses, placEff = 0, addArgs = addArgs)))
cont_mat <- optContr(mods, w = allocation)

grd <- expand.grid(max_eff = c(0.2), sd = c(0.4), n_total = c(140,168))
power_list <- vector("list", nrow(grd))
dat_n <- t(sapply(grd$n_total, function(n) round(n*allocation/sum(allocation))))
colnames(dat_n) <- paste0("D", doses)
for (i in 1:nrow(grd)) {
  ######
  mods <- do.call(Mods, append(resp_mod_list, list(maxEff = grd$max_eff[i], doses = doses,
  placEff = 0, addArgs = addArgs)))
  n <- dat_n[i, ]
  power_list[[i]] <- powMCT(cont_mat, alpha, mods, n, grd$sd[i], control = mvt_control)
}
power_df <- as.data.frame(do.call("rbind", power_list))
mu <- getResp(mods)
parList <- attr(mu, 'parList')
mod_nams <- DoseFinding:::getModNams(parList)
colnames(power_df) <- mod_nams
power_df[['mean power']] <- apply(power_df, 1, mean)
result <- cbind(grd, power_df, dat_n)
power_non_monotonic_nsample_beta[1] <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`[1]
power_non_monotonic_nsample_beta[3] <- result$`betaMod (delta1=1.396434,delta2=1.040978,scal=9.6)`[2]
```


```{r}
#store results
results_non_monotonic_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = power_non_monotonic_nsample_linear,
  Emax = power_non_monotonic_nsample_emax,
  sigEmax = power_non_monotonic_nsample_sigemax,
  quadratic = power_non_monotonic_nsample_quadratic,
  beta = power_non_monotonic_nsample_beta
)


kable(results_non_monotonic_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 6), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Non-monotonic scenario" = 6), font_size = 15, bold = TRUE)
    
```

## Variability scenario


### varying expected effect for maximum dose

```{r warning=FALSE}
# assumed dose - response model
sim_models_var_linear = list(linear = NA,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_exp = list( exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_emax = list(emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)



# Simulation parameters
sim_parameters_var = list(n = Nsample_var, 
                      doses = doses_var,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)

# perform Simulations

list_models <- list(sim_models_var_linear, sim_models_var_exp, sim_models_var_emax)
chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_var <- foreach(k = chunks, .combine = c) %dorng% {
  
  lapply(k, function (i) {
    
    func_sim(var_modelsPack, list_models[[i]], sim_parameters_var) 
    
  })
  
}
  

# store results
results_var_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  linear = results_list_var[[1]]$sim_results$power,
  exponential = results_list_var[[2]]$sim_results$power,
  emax = results_list_var[[3]]$sim_results$power,
  average = c((sum(results_list_var[[1]]$sim_results$power[1], results_list_var[[2]]$sim_results$power[1],results_list_var[[3]]$sim_results$power[1])/3),
              (sum(results_list_var[[1]]$sim_results$power[2], results_list_var[[2]]$sim_results$power[2],results_list_var[[3]]$sim_results$power[2])/3),
              (sum(results_list_var[[1]]$sim_results$power[3], results_list_var[[2]]$sim_results$power[3],results_list_var[[3]]$sim_results$power[3])/3),
              (sum(results_list_var[[1]]$sim_results$power[4], results_list_var[[2]]$sim_results$power[4],results_list_var[[3]]$sim_results$power[4])/3),
              (sum(results_list_var[[1]]$sim_results$power[5], results_list_var[[2]]$sim_results$power[5],results_list_var[[3]]$sim_results$power[5])/3))
)

kable(results_var_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects" = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Variability scenario" = 5), font_size = 15, bold = TRUE)


```

### varying sample size
```{r warning=FALSE}
# assume maximum effect = 0.2
sim_models_var_linear$max_effect <- expectedEffect_fix
sim_models_var_exp$max_effect <- expectedEffect_fix
sim_models_var_emax$max_effect <- expectedEffect_fix


# store results
power_var_nsample_linear <- vector()
power_var_nsample_exp <- vector()
power_var_nsample_emax <- vector()

# # Loop over nsample values
# for (i in seq_along(nsample_list_var)) {
#   
#   # Update nsample in simulation parameters
#   sim_parameters_var$n <- nsample_list_var[[i]]
# 
#   
#   # power values for different assumed true models
#   power_nsample_linear <- func_sim(var_modelsPack, sim_models_var_linear, sim_parameters_var)
#   power_var_nsample_linear[i] <- power_nsample_linear$sim_results$power
#   
#   power_nsample_exp <- func_sim(var_modelsPack, sim_models_var_exp, sim_parameters_var)
#   power_var_nsample_exp[i] <- power_nsample_exp$sim_results$power
#   
#   power_nsample_emax <- func_sim(var_modelsPack, sim_models_var_emax, sim_parameters_var)
#   power_var_nsample_emax[i] <-power_nsample_emax$sim_results$power
#   
#   
# }

var_modelsPack$max_effect <- expectedEffect_fix
#list of different samole sizes
nsample_list_var = list(20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1),
                    20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1),
                    20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1))

list_models <- list(sim_models_var_linear, sim_models_var_linear, sim_models_var_linear, sim_models_var_linear, 
                    sim_models_var_exp, sim_models_var_exp, sim_models_var_exp, sim_models_var_exp, 
                    sim_models_var_emax, sim_models_var_emax, sim_models_var_emax, sim_models_var_emax)


chunks <- chunkVector(seq_along(list_models), getDoParWorkers())

results_list_var_nsample <- foreach(k = chunks, .combine = c, .export = c(as.character(var_modelsPack), as.character(nsample_list)))  %dorng% {
  lapply(k, function (i) {
    sim_parameters = list(n = nsample_list_var[[i]], 
                      doses = doses_var,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)
    
    
    func_sim(var_modelsPack, list_models[[i]], sim_parameters) 
    
  })
  
}


results_var_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = c(results_list_var_nsample[[1]]$sim_results$power, results_list_var_nsample[[2]]$sim_results$power, results_list_var_nsample[[3]]$sim_results$power, results_list_var_nsample[[4]]$sim_results$power),
  Exponential =c(results_list_var_nsample[[5]]$sim_results$power, results_list_var_nsample[[6]]$sim_results$power, results_list_var_nsample[[7]]$sim_results$power, results_list_var_nsample[[8]]$sim_results$power),
  Emax = c(results_list_var_nsample[[9]]$sim_results$power, results_list_var_nsample[[10]]$sim_results$power, results_list_var_nsample[[11]]$sim_results$power, results_list_var_nsample[[12]]$sim_results$power),
  Average = c((sum(results_list_var_nsample[[1]]$sim_results$power, results_list_var_nsample[[5]]$sim_results$power, results_list_var_nsample[[9]]$sim_results$power)/3),
              (sum(results_list_var_nsample[[2]]$sim_results$power, results_list_var_nsample[[6]]$sim_results$power, results_list_var_nsample[[10]]$sim_results$power)/3),
              (sum(results_list_var_nsample[[3]]$sim_results$power, results_list_var_nsample[[7]]$sim_results$power, results_list_var_nsample[[11]]$sim_results$power)/3),
              (sum(results_list_var_nsample[[4]]$sim_results$power, results_list_var_nsample[[8]]$sim_results$power, results_list_var_nsample[[12]]$sim_results$power)/3))
)

kable(results_var_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Variability scenario" = 5), font_size = 15, bold = TRUE)

```
