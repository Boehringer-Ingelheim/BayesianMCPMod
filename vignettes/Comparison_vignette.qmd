---
title: "Comparison frequentist & Bayesian"
subtitle: "WORK IN PROGRESS"
date: today
format: 
  html:
    fig-height: 3.5
    self-contained: true
    toc: true
    number-sections: true
    #bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{Simulation Example of Bayesian MCPMod and MCPMod}
    %\VignetteEncoding{UTF-8}
    %\VignetteEngine{quarto::html}
---


```{r}
#| code-summary: setup
#| code-fold: true
#| message: false
#| warning: false

#' Display Parameters Table
#'
#' This function generates a markdown table displaying the names and values of parameters
#' from a named list.
#'
#' @param named_list A named list where each name represents a parameter name and the list
#'   element represents the parameter value. Date values in the list are automatically
#'   converted to character strings for display purposes.
#'
#' @return Prints a markdown table with two columns: "Parameter Name" and "Parameter Values".
#'   The function does not return a value but displays the table directly to the output.
#'
#' @importFrom knitr kable
#' @examples
#' params <- list("Start Date" = as.Date("2020-01-01"),
#'                "End Date" = as.Date("2020-12-31"),
#'                "Threshold" = 10)
#' display_params_table(params)
#'
#' @export
display_params_table <- function(named_list) {
  display_table <- data.frame()
  value_names <- data.frame()
  for (i in 1:length(named_list)) {
    # dates will display as numeric by default, so convert to char first
    if (class(named_list[[i]]) == "Date") {
      named_list[[i]] = as.character(named_list[[i]])
    }
    if (!is.null(names(named_list[[i]]))) {
      value_names <- rbind(value_names, paste(names(named_list[[i]]), collapse = ', '))
    }
    values <- data.frame(I(list(named_list[[i]])))
    display_table <- rbind(display_table, values)
  }
  
  round_numeric <- function(x, digits = 3) {
    if (is.numeric(x)) {
      return(round(x, digits))
    } else {
      return(x)
    }
  }
  
  display_table[1] <- lapply(display_table[1], function(sublist) {
    lapply(sublist, round_numeric)
  })
  
  class(display_table[[1]]) <- "list"
  
  if (nrow(value_names) == 0) {
    knitr::kable(
      cbind(names(named_list), display_table),
      col.names = c("Name", "Value")
    )
  } else {
    knitr::kable(
      cbind(names(named_list), value_names, display_table),
      col.names = c("Name", "Value Labels", "Value")
    )
  }
}

# function to solve power results for tables (different max eff) BayesianMCPMod
# return(successrates models, average)
extract_success_rates <- function(results_list, models) {
  success_rates <- list()

  for (i in seq_along(results_list)) {
    success_rate <- c()
    for (model in models) {
      success_rate <- c(success_rate, attr(results_list[[i]][[model]]$BayesianMCP,"successRate"))
    }
    success_rates[[paste0("Bay_",  attr(results_list[[i]],"maxEff"))]] <- c(success_rate, attr(results_list[[i]], "avgSuccessRate"))
  }

  return(success_rates)
  }

# function to solve power results for tables (different nsample) BayesianMCPMod
#models <c-(min_scenario)
extract_success_rates_nsample <- function(results_list, models) {
  success_rates <- list()

  for (i in seq_along(results_list)) {
    success_rate <- c()
    for (model in models) {
      success_rate <- c(success_rate, attr(results_list[[i]][[model]]$BayesianMCP,"successRate"))
    }
    success_rates[[paste0("Bay_", names(results_list)[i])]] <- c(success_rate,  attr(results_list[[i]],"avgSuccessRate"))
  }

  return(success_rates)
}

#input: result_list, models =
extract_success_rates_nsim <- function(results_list, models, n_sim) {
  success_rates <- list()
  for (model in models) {
    success_rate <- c()
    for (i in seq_along(n_sim)) {

      success_rate <- c(success_rate, attr(results_list[[i]][[model]]$BayesianMCP,"successRate"))
    }
    success_rates[[paste0("Bay_", model)]] <- c(success_rate)
  }

  return(success_rates)
}


print_result_Bay_max_eff <- function(results, scenario, variable) {

  result_table <- t(data.table(
    Bay_0.05 = results$Bay_0.05,
    Bay_0.1 = results$Bay_0.1,
    Bay_0.2 = results$Bay_0.2,
    Bay_0.3 = results$Bay_0.3,
    Bay_0.5 = results$Bay_0.5))

  result_table <- as.data.table(result_table)
  names(result_table) <- scenario
  #return(result_table)

  kable_result <- kable(cbind(variable, result_table))%>%
    kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects " = length(scenario)+1), font_size = 15, bold = TRUE)

  list(result_table = result_table, kable_result = kable_result)
}



print_result_Bay_nsample <- function(results, scenario, variable) {

  result_table <- t(data.table(
    Bay_1 = results$`Bay_nsample_c(40, 20, 20, 20, 40)`,
    Bay_2 = results$`Bay_nsample_c(30, 30, 30, 30, 30)`,
    Bay_3 = results$`Bay_nsample_c(48, 24, 24, 24, 48)`,
    Bay_4 = results$`Bay_nsample_c(36, 36, 36, 36, 36)`))

  result_table <- as.data.table(result_table)
  names(result_table) <- scenario
  #return(result_table)

  kable_result <- kable(cbind(variable, result_table))%>%
    kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes " = length(scenario)+1), font_size = 15, bold = TRUE)

  list(result_table = result_table, kable_result = kable_result)
}



library(BayesianMCPMod)
library(RBesT)
library(clinDR)
library(dplyr)
library(tibble)
library(reactable)
library(DoseFinding)
library(MCPModPack)
library(kableExtra)
library(data.table)
#library(here)
#invisible(here("functions_simulations.R"))
#source("functions_simulations.R")

set.seed(7015)
```


# Introduction 

This vignette demonstrates the application of the {BayesianMCPMod} package for sample size calculations and the comparison with the {MCPModPack} package.

```{r}
#######  General assumptions  #########
# simulations
n_sim <- 10

# Define the list of sample sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))
nsample_vector <- c("(40,20,20,20,40)", "(30,30,30,30,30)", "(48,24,24,24,48)",  "(36,36,36,36,36)")

# define input parameters
doses.sim <- c(0,1,2,4,8)   # dose levels
max.dose <- max(doses.sim) # specify max dose possibly available
plc.guess <-  0 # expected placebo effect
Nsample <-c(40,40,40,40,40) #,36*c(1,1,1,1)) #list(20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1))
expectedEffect_fix <- 0.2  #c(0.05,0.1,0.2,0.3,0.5)
expectedEffect <- c(0.05,0.1,0.2,0.3,0.5)
sd.sim <- c(0.4)

#input paramters variability scenario
doses_var <- c(0, 1, 4, 8)
sd.sim_var <- 0.4
Nsample_var <- c(25, 25, 25, 25)
nsample_list_var <- list(20*c(2,1,1,2),30*c(1,1,1,1), 24*c(2,1,1,2),36*c(1,1,1,1))


# define model functions  
emax.g <- guesst(d = doses.sim[2], p = 0.6, "emax") 
exp.g <- guesst(d=doses.sim[2],p=0.05,model="exponential", Maxd=max.dose)
logit.g <- guesst(d=c(doses.sim[2],doses.sim[3]),p=c(0.1,0.9),"logistic",Maxd=max.dose) 
sigEmax.g <- guesst(d=c(doses.sim[2],doses.sim[3]),p=c(0.15,0.75), model = "sigEmax") 
quad.g <- guesst(d=doses.sim[2],p=0.35,model="quadratic")
beta.g <- guesst(d=doses.sim[2],p=0.2,model="betaMod", dMax=5.5, scal=8.6, Maxd=max.dose)

### define models to be tested in MCPMod
models <- Mods(linear=NULL, 
               emax = emax.g,
               exponential = exp.g,
               logistic=logit.g,
               sigEmax = sigEmax.g,
               quadratic = quad.g,
               betaMod = beta.g,
               doses = doses.sim,
               placEff = plc.guess, 
               maxEff = expectedEffect_fix,
               direction = "increasing",
               addArgs = list(scal=8.6) # SB: Please add this to all Mods where we are using the beta model 
)

alpha <- 0.05

display_params_table(models)


kable(t(as.data.table(cbind(doses.sim, Nsample))))%>%
    kable_classic(full_width = TRUE)%>%
    add_header_above(c( "Doses" = 6), font_size = 15, bold = TRUE)


kable(t(data.table(placebo_guess = plc.guess,
                 sd = sd.sim[1],
                 alpha = alpha )))%>%
    kable_classic(full_width = TRUE)

```
## Scenarios

In order to test and compare BayesianMCPMod and MCPModPack sample size calculations in different scenarios, the data
used for the comparisons will be simulated multiple times using different input values.
Every scenario will be named to make the differentiation between each scenario simpler.
Altogether, four different scenarios were simulated.

```{r}

#Specification of considered models for different scenarios for BayesianMCPMod

min_scenario <- c("linear", "exponential", "emax")
min_models <- Mods(linear=NULL, 
                   exponential = exp.g,
                  emax = emax.g,
                  doses = doses.sim,
                  placEff = plc.guess, 
                  maxEff = expectedEffect_fix,
                  direction = "increasing"
)
plot(min_models, main = "minimal Scenario")


monotonic_scenario <- c("linear", "exponential", "emax", "logistic", "sigEmax")

monotonic_models <- Mods(linear=NULL, 
               exponential = exp.g,
               emax = emax.g,
               logistic=logit.g,
               sigEmax = sigEmax.g,
               doses = doses.sim,
               placEff = plc.guess, 
               maxEff = expectedEffect_fix,
               direction = "increasing"
)
plot(monotonic_models, main = "monotonic Scenario")


non_monotonic_scenario <- c("linear", "emax", "sigEmax", "quadratic", "betaMod")

non_monotonic_models <- Mods(linear=NULL, 
               emax = emax.g,
               sigEmax = sigEmax.g,
               quadratic = quad.g,
               betaMod = beta.g,
               doses = doses.sim,
               placEff = plc.guess, 
               maxEff = expectedEffect_fix,
               direction = "increasing",
               addArgs = list(scal=8.6)
)
plot(non_monotonic_models,main = "non monotonic Scenario")


variability_scenario <- c("linear","exponential", "emax",  "logistic", "sigEmax")

kable(t(as.data.table(cbind(doses_var, Nsample_var))))%>%
    kable_classic(full_width = TRUE)%>%
    add_header_above(c( "Doses variability scenario" = 5), font_size = 15)

var_models <- Mods(linear=NULL, 
               exponential = exp.g,
               emax = emax.g,
               logistic=logit.g,
               sigEmax = sigEmax.g,
               doses = doses_var,
               placEff = plc.guess, 
               maxEff = expectedEffect_fix,
               direction = "increasing"
)
plot(var_models, main = "variability Scenario")

```




# MCPModPack



```{r}

#Specification of considered models for different scenarios for MCPModPack

min_modelsPack = list(linear = NA,
              exponential = 4.447149,
              emax = 0.6666667)

monotonic_modelsPack = list(linear = NA,
              exponential = 4.447149,
              emax = 0.6666667,
              logistic = c(1.5, 0.2275598),
              sigEmax =  c(1.528629, 4.087463))

non_monotonic_modelsPack = list(linear = NA,
              emax = 0.6666667 ,
              sigEmax =  c(1.528629, 4.087463),
              quadratic = -0.09688711 ,
              betaMod(dose = doses.sim, e0 = plc.guess, eMax = 5.5, delta1 = 1, delta2 = 0.2, scal= 8.6))

var_modelsPack = list(linear = NA,
              exponential = 4.447149,
              emax = 0.6666667,
              logistic = c(1.5, 0.2275598),
              sigEmax =  c(1.528629, 4.087463))

```

## minimal

### maximum effect
```{r warning=FALSE}
# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                             exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)

# Initialize list to store results
results_list_min <- list()
  
# Run simulation
func_sim <- function(models ,sim_models, sim_parameters){

sim_result = MCPModSimulation(endpoint_type = "Normal", 
                                 models = models, 
                                 alpha = alpha, 
                                 direction = "increasing", 
                                 model_selection = "aveAIC", 
                                 Delta = 0.1,
                                 sim_models = sim_models,
                                 sim_parameters = sim_parameters)
}

# Simulation for different assumed models
power_min_linear <- func_sim(min_modelsPack, sim_models_min_linear, sim_parameters) 
power_min_exp <- func_sim(min_modelsPack, sim_models_min_exp, sim_parameters)
power_min_emax <- func_sim(min_modelsPack,sim_models_min_emax, sim_parameters)



#store results
results_min_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  Linear = c(power_min_linear$sim_results$power),
  Exponential = c(power_min_exp$sim_results$power),
  Emax = c(power_min_emax$sim_results$power),
  Average = c(sum(power_min_linear$sim_results$power[1], power_min_exp$sim_results$power[1], power_min_emax$sim_results$power[1])/3,
              sum(power_min_linear$sim_results$power[2], power_min_exp$sim_results$power[2], power_min_emax$sim_results$power[2])/3,
              sum(power_min_linear$sim_results$power[3], power_min_exp$sim_results$power[3], power_min_emax$sim_results$power[3])/3,
              sum(power_min_linear$sim_results$power[4], power_min_exp$sim_results$power[4], power_min_emax$sim_results$power[4])/3,
              sum(power_min_linear$sim_results$power[5], power_min_exp$sim_results$power[5], power_min_emax$sim_results$power[5])/3)
)

kable(results_min_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects " = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Minimal scenario " = 5), font_size = 15, bold = TRUE)
    


```

### Nsample
```{r warning=FALSE}
#list of different samole sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))

# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)


# store results
power_min_nsample_linear <- vector()
power_min_nsample_exp <- vector()
power_min_nsample_emax <- vector()

# Loop over nsample values
for (i in seq_along(nsample_list)) {
  
  # Update nsample in simulation parameters
  sim_parameters$n <- nsample_list[[i]]
  
  # Set max_effect to 0.2
  min_modelsPack$max_effect <- expectedEffect_fix
  
  # power values for different assumed true models
  power_nsample_linear <- func_sim(min_modelsPack, sim_models_min_linear, sim_parameters)
  power_min_nsample_linear[i] <- power_nsample_linear$sim_results$power
  
  power_nsample_exp <- func_sim(min_modelsPack, sim_models_min_exp, sim_parameters)
  power_min_nsample_exp[i] <-power_nsample_exp$sim_results$power
  
  power_nsample_emax <- func_sim(min_modelsPack, sim_models_min_emax, sim_parameters)
  power_min_nsample_emax[i] <- power_nsample_exp$sim_results$power
  
}

# store results
results_min_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = c(power_min_nsample_linear),
  Exponential = c(power_min_nsample_exp),
  Emax = c(power_min_nsample_emax),
  Average = c(sum(power_min_nsample_linear[1], power_min_nsample_exp[1], power_min_nsample_emax[1])/3,
              sum(power_min_nsample_linear[2], power_min_nsample_exp[2], power_min_nsample_emax[2])/3,
              sum(power_min_nsample_linear[3], power_min_nsample_exp[3], power_min_nsample_emax[3])/3,
              sum(power_min_nsample_linear[4], power_min_nsample_exp[4], power_min_nsample_emax[4])/3)
)

kable(results_min_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes " = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Minimal scenario " = 5), font_size = 15, bold = TRUE)
    


```

## monotonic

### maximum effect
```{r warning=FALSE}

sim_models_monotonic_linear = list(linear = NA,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_exp = list( exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_logistic = list(logistic = c(1.5, 0.2275598),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_sigemax= list(sigemax =  c(1.528629, 4.087463),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_monotonic_emax= list(emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_parameters = list(n = Nsample, 
                      doses = doses.sim,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)

# Initialize list to store results
results_list_monotonic <- list()
  

power_monotonic_linear <- func_sim(monotonic_modelsPack, sim_models_monotonic_linear, sim_parameters) 
power_monotonic_exp <- func_sim(monotonic_modelsPack, sim_models_monotonic_exp, sim_parameters)
power_monotonic_logistic <- func_sim(monotonic_modelsPack, sim_models_monotonic_logistic, sim_parameters)
power_monotonic_sigemax <- func_sim(monotonic_modelsPack, sim_models_monotonic_sigemax, sim_parameters)
power_monotonic_emax <- func_sim(monotonic_modelsPack, sim_models_monotonic_emax, sim_parameters)


results_monotonic_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  Linear = power_monotonic_linear$sim_results$power,
  Exponential = power_monotonic_exp$sim_results$power,
  Emax = power_monotonic_emax$sim_results$power,
  Logistic = power_monotonic_logistic$sim_results$power,
  sigEmax = power_monotonic_sigemax$sim_results$power,
  Average = c(sum(power_monotonic_linear$sim_results$power[1], power_monotonic_exp$sim_results$power[1], power_monotonic_emax$sim_results$power[1], power_monotonic_logistic$sim_results$power[1], power_monotonic_sigemax$sim_results$power[1])/5,
              sum(power_monotonic_linear$sim_results$power[2], power_monotonic_exp$sim_results$power[2], power_monotonic_emax$sim_results$power[2], power_monotonic_logistic$sim_results$power[2], power_monotonic_sigemax$sim_results$power[2])/5,
              sum(power_monotonic_linear$sim_results$power[3], power_monotonic_exp$sim_results$power[3],power_monotonic_emax$sim_results$power[3], power_monotonic_logistic$sim_results$power[3], power_monotonic_sigemax$sim_results$power[3])/5,
              sum(power_monotonic_linear$sim_results$power[4], power_monotonic_exp$sim_results$power[4],power_monotonic_emax$sim_results$power[4], power_monotonic_logistic$sim_results$power[4], power_monotonic_sigemax$sim_results$power[4])/5,
              sum(power_monotonic_linear$sim_results$power[5], power_monotonic_exp$sim_results$power[5],power_monotonic_emax$sim_results$power[5], power_monotonic_logistic$sim_results$power[5], power_monotonic_sigemax$sim_results$power[5])/5)
)

kable(results_monotonic_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects " = 7), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Monotonic scenario " = 7), font_size = 15, bold = TRUE)
    

```

### Nsample
```{r warning=FALSE}
# assume maximum effect = 0.2
sim_models_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_monotonic_exp$max_effect <- expectedEffect_fix
sim_models_monotonic_emax$max_effect <- expectedEffect_fix
sim_models_monotonic_logistic$max_effect <- expectedEffect_fix
sim_models_monotonic_sigemax$max_effect <- expectedEffect_fix

# store results
power_monotonic_nsample_linear <- vector()
power_monotonic_nsample_exp <- vector()
power_monotonic_nsample_emax <- vector()
power_monotonic_nsample_logistic <- vector()
power_monotonic_nsample_sigemax <- vector()


# Loop over nsample values
for (i in seq_along(nsample_list)) {
  
  # Update nsample in simulation parameters
  sim_parameters$n <- nsample_list[[i]]

  
  # power values for different assumed true models
  power_nsample_linear <- func_sim(monotonic_modelsPack, sim_models_monotonic_linear, sim_parameters)
  power_monotonic_nsample_linear[i] <- power_nsample_linear$sim_results$power
  
  power_nsample_exp <- func_sim(monotonic_modelsPack, sim_models_monotonic_exp, sim_parameters)
  power_monotonic_nsample_exp[i] <- power_nsample_exp$sim_results$power
  
  power_nsample_emax <- func_sim(monotonic_modelsPack, sim_models_monotonic_emax, sim_parameters)
  power_monotonic_nsample_emax[i] <-power_nsample_emax$sim_results$power
  
  power_nsample_logistic <- func_sim(monotonic_modelsPack, sim_models_monotonic_logistic, sim_parameters)
  power_monotonic_logistic <- power_nsample_logistic$sim_results$power
  
  power_nsample_sigemax <- func_sim(monotonic_modelsPack, sim_models_monotonic_sigemax, sim_parameters)
  power_monotonic_nsample_sigemax[i] <- power_nsample_sigemax$sim_results$power
  
}


results_monotonic_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = power_monotonic_nsample_linear,
  Exponential = power_monotonic_nsample_exp,
  Emax = power_monotonic_nsample_emax,
  Logistic = power_monotonic_logistic,
  sigEmax = power_monotonic_nsample_sigemax)


kable(results_monotonic_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 6), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Monotonic scenario" = 6), font_size = 15, bold = TRUE)
    

```
## non - monotonic 

### maximum effects

```{r warning=FALSE}

sim_models_non_monotonic_linear = list(linear = NA,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_non_monotonic_emax = list(emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_non_monotonic_sigemax = list(sigemax =  c(1.528629, 4.087463),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_non_monotonic_quadratic = list(quadratic = -0.09688711,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_non_monotonic_beta = list( betaMod(dose = doses.sim, e0 = plc.guess, eMax = 5.5, delta1 = 1, delta2 = 0.2, scal= 8.6),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)


power_non_monotonic_linear <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_linear, sim_parameters) 
power_non_monotonic_emax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_emax, sim_parameters) 
power_non_monotonic_sigemax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_sigemax, sim_parameters) 
power_non_monotonic_quadratic <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_quadratic, sim_parameters) 
#power_non_monotonic_beta <- func_sim(sim_models_non_monotonic_beta, sim_parameters) 

#linear, emax, sigemax, quadratic
results_non_monotonic_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  Linear = power_non_monotonic_linear$sim_results$power,
  Emax = power_non_monotonic_emax$sim_results$power,
  sigEmax = power_non_monotonic_sigemax$sim_results$power,
  quadratic = power_non_monotonic_quadratic$sim_results$power)


kable(results_non_monotonic_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects" = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Non-monotonic scenario" = 5), font_size = 15, bold = TRUE)
    

```

### Nsample

```{r warning=FALSE}
#beta model fehlt!!!

# assume maximum effect = 0.2
sim_models_non_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_non_monotonic_emax$max_effect <- expectedEffect_fix
sim_models_non_monotonic_sigemax$max_effect <- expectedEffect_fix
sim_models_non_monotonic_quadratic$max_effect <- expectedEffect_fix

# store results
power_non_monotonic_nsample_linear <- vector()
power_non_monotonic_nsample_emax <- vector()
power_non_monotonic_nsample_quadratic <- vector()
power_non_monotonic_nsample_sigemax <- vector()

# Loop over nsample values
for (i in seq_along(nsample_list)) {
  
  # Update nsample in simulation parameters
  sim_parameters$n <- nsample_list[[i]]

  
  # power values for different assumed true models
  power_nsample_linear <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_linear, sim_parameters)
  power_non_monotonic_nsample_linear[i] <- power_nsample_linear$sim_results$power
  
  power_nsample_emax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_emax, sim_parameters)
  power_non_monotonic_nsample_emax[i] <-power_nsample_emax$sim_results$power
  
  power_nsample_sigemax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_sigemax, sim_parameters)
  power_non_monotonic_nsample_sigemax[i] <- power_nsample_sigemax$sim_results$power
  
   power_nsample_quadratic <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_quadratic, sim_parameters)
  power_non_monotonic_nsample_quadratic[i] <- power_nsample_quadratic$sim_results$power
  
  
}

results_non_monotonic_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = power_non_monotonic_nsample_linear,
  Emax = power_non_monotonic_nsample_emax,
  sigEmax = power_non_monotonic_nsample_sigemax,
  quadratic = power_non_monotonic_nsample_quadratic
)


kable(results_non_monotonic_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 5), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Non-monotonic scenario" = 5), font_size = 15, bold = TRUE)
    



```

## variability
### maximum effect

```{r warning=FALSE}


sim_models_var_linear = list(linear = NA,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_exp = list( exponential = 4.447149,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_emax = list(emax = 0.6666667,
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_sigemax = list(sigemax =  c(1.528629, 4.087463),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

sim_models_var_logistic = list(logistic = c(1.5, 0.2275598),
                  max_effect = c(0.05,0.1,0.2,0.3,0.5),
                  sd = rep(sd.sim_var, length(doses_var)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters_var = list(n = Nsample_var, 
                      doses = doses_var,
                      dropout_rate = 0.0, 
                      go_threshold = 0.1, 
                      nsims = n_sim)


power_var_linear <- func_sim(var_modelsPack, sim_models_var_linear, sim_parameters_var)
power_var_exp <- func_sim(var_modelsPack, sim_models_var_exp, sim_parameters_var)
power_var_emax <- func_sim(var_modelsPack, sim_models_var_emax, sim_parameters_var)
power_var_sigemax <- func_sim(var_modelsPack, sim_models_var_sigemax, sim_parameters_var)
power_var_logistic <- func_sim(var_modelsPack, sim_models_var_logistic, sim_parameters_var)

results_var_MCP <- data.table(
  Max_eff = c(0.05, 0.1, 0.2, 0.3, 0.5),
  Linear = power_var_linear$sim_results$power,
  Exponential = power_var_exp$sim_results$power,
  Emax = power_var_emax$sim_results$power,
  Logistic = power_var_logistic$sim_results$power,
  sigEmax = power_var_sigemax$sim_results$power
)

kable(results_var_MCP)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different expected effects" = 6), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Variability scenario" = 6), font_size = 15, bold = TRUE)


```

### Nsample
```{r warning=FALSE}
# assume maximum effect = 0.2
sim_models_var_linear$max_effect <- expectedEffect_fix
sim_models_var_exp$max_effect <- expectedEffect_fix
sim_models_var_emax$max_effect <- expectedEffect_fix
sim_models_var_sigemax$max_effect <- expectedEffect_fix
sim_models_var_logistic$max_effect <- expectedEffect_fix

# store results
power_var_nsample_linear <- vector()
power_var_nsample_exp <- vector()
power_var_nsample_logistic <- vector()
power_var_nsample_sigemax <- vector()
power_var_nsample_emax <- vector()

# Loop over nsample values
for (i in seq_along(nsample_list_var)) {
  
  # Update nsample in simulation parameters
  sim_parameters_var$n <- nsample_list_var[[i]]

  
  # power values for different assumed true models
  power_nsample_linear <- func_sim(var_modelsPack, sim_models_var_linear, sim_parameters_var)
  power_var_nsample_linear[i] <- power_nsample_linear$sim_results$power
  
  power_nsample_exp <- func_sim(var_modelsPack, sim_models_var_exp, sim_parameters_var)
  power_var_nsample_exp[i] <- power_nsample_exp$sim_results$power
  
  power_nsample_emax <- func_sim(var_modelsPack, sim_models_var_emax, sim_parameters_var)
  power_var_nsample_emax[i] <-power_nsample_emax$sim_results$power
  
  power_nsample_sigemax <- func_sim(var_modelsPack, sim_models_var_sigemax, sim_parameters_var)
  power_var_nsample_sigemax[i] <- power_nsample_sigemax$sim_results$power
  
  power_nsample_logistic <- func_sim(var_modelsPack, sim_models_var_logistic, sim_parameters_var)
  power_var_nsample_logistic[i] <- power_nsample_logistic$sim_results$power
  
}


results_var_MCP_nsample <- data.table(
  N_sample = c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"),
  Linear = power_var_nsample_linear,
  Exponential = power_var_nsample_exp,
  Emax = power_var_nsample_emax,
  sigEmax = power_var_nsample_sigemax,
  Logistic = power_var_nsample_logistic
)

kable(results_var_MCP_nsample)%>%
  kable_classic(full_width = TRUE)%>%
    add_header_above(c("Power results different sample sizes" = 6), font_size = 15, bold = TRUE)%>%
    add_header_above(c("Variability scenario" = 6), font_size = 15, bold = TRUE)

```


# BayesianMCPMod


# Prior Specification
We use an uninformativ prior.

```{r}
uninf_prior_list <- list(
                   Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn"),
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim, param = "mn")
                   
)
```

To calculate success probabilities for the different assumed dose-response models and the specified trial design we will apply the assessDesign function. 

## minimal
### Maximum effect

First we assume a fix sample size of 40 patients per group and different maximum effects.

```{r}

# list to store results
results_list_Bay_min <- list()

# Simulation with different maximum effects
results_list_Bay_min <- purrr::map( c(0.05,0.1,0.2,0.3,0.5), function(i) {
  min_models <- Mods(linear=NULL, 
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess, 
                     maxEff = i,
                     direction = "increasing")
  #optimal contrasts
  contM <- getContr(mods = min_models, 
                    dose_levels = doses.sim, 
                    prior_list = uninf_prior_list, 
                    dose_weights = c(1,1,1,1,1))

 # Simulation step
  success_probabilities_min <- assessDesign(
    n_patients  = Nsample,
    mods        = min_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = n_sim,
    alpha_crit_val = alpha, 
    contr = contM)

  # Store result in list
  results_list_Bay_min[[paste0("max_effect_", expectedEffect[i])]] <- success_probabilities_min
})


results_min_Bay <- extract_success_rates(results_list_Bay_min, min_scenario)

minimal_Bay <- print_result_Bay_max_eff(results_min_Bay, c(min_scenario, "average"), expectedEffect)

minimal_Bay$kable_result



```
### Nsample

Now we assume an fix maximum effect of 0.2 and different sample sizes.

```{r}
# Define the list of sample sizes
nsample_list = list(20*c(2,1,1,1,2),30*c(1,1,1,1,1), 24*c(2,1,1,1,2),36*c(1,1,1,1,1))


# Initialize list to store results
results_list_nsample_min_Bay <- list()

#Models with maxEff = 0.2
min_models <- Mods(linear=NULL, 
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess, 
                     maxEff = expectedEffect_fix,
                     direction = "increasing")
  #optimal contrasts
contM <- getContr(mods = min_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

# Loop over nsample values
for (i in seq_along(nsample_list)) {
  

# Simulations 
success_probabilities_min <- assessDesign(
  n_patients  = nsample_list[[i]],
  mods        = min_models,
  prior_list  = uninf_prior_list,
  sd          = sd.sim,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_nsample_min_Bay[[paste0("nsample_", nsample_list[i])]] <- success_probabilities_min
  
}


results_min_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_min_Bay, min_scenario)
  
minimal_nsample_Bay <- print_result_Bay_nsample(results_min_Bay_nsample, c(min_scenario, "average"), nsample_vector)
minimal_nsample_Bay$kable_result



```



## monotonic scenario
 
### Maximum effect

```{r}
results_list_Bay_monotonic <- list()


results_list_Bay_monotonic <- purrr::map(c(0.05,0.1,0.2,0.3,0.5), function(i) {
  
 monotonic_models <- Mods(linear=NULL, 
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess, 
                         maxEff = i,
                         direction = "increasing")
       
  #optimal contrasts
contM <- getContr(mods = monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

success_probabilities_monotonic <- assessDesign(
  n_patients  = Nsample,
  mods        = monotonic_models,
  prior_list  = uninf_prior_list,
  sd          = sd.sim,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_Bay_monotonic[[paste0("max_effect_", expectedEffect[i])]] <- success_probabilities_monotonic
  
})
##power results in vector for tables
results_monotonic_Bay <- extract_success_rates(results_list_Bay_monotonic, monotonic_scenario)


monotonic_Bay <- print_result_Bay_max_eff(results_monotonic_Bay, c(monotonic_scenario, "average"), expectedEffect)
  
monotonic_Bay$kable_result



```

### Nsample
```{r}
# Initialize list to store results
results_list_nsample_monotonic_Bay <- list()

monotonic_models <- Mods(linear=NULL, 
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess, 
                         maxEff = expectedEffect_fix,
                         direction = "increasing")
 
# optimal contrasts
contM <- getContr(mods = monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))  

# Loop over nsample values
for (i in seq_along(nsample_list)) {
  


success_probabilities_monotonic <- assessDesign(
  n_patients  = nsample_list[[i]],
  mods        = monotonic_models,
  prior_list  = uninf_prior_list,
  sd          = sd.sim,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_nsample_monotonic_Bay[[paste0("nsample_", nsample_list[i])]] <- success_probabilities_monotonic
  
}

results_monotonic_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_monotonic_Bay, monotonic_scenario)


monotonic_nsample_Bay <- print_result_Bay_nsample(results_monotonic_Bay_nsample, c(monotonic_scenario, "average"), nsample_vector)
monotonic_nsample_Bay$kable_result


```


## non-monotonic scenario
### Maximum effect
```{r}
results_list_Bay_non_monotonic <- list()

results_list_Bay_non_monotonic <- purrr::map(c(0.05,0.1,0.2,0.3,0.5), function(i) {
  
 non_monotonic_models <- Mods(linear=NULL, 
                               emax = emax.g,
                               sigEmax = sigEmax.g,
                               quadratic = quad.g,
                               betaMod = beta.g,
                               doses = doses.sim,
                               placEff = plc.guess, 
                               maxEff = i,
                               direction = "increasing",
                               addArgs = list(scal=8.6))
                 
  #optimal contrasts
contM <- getContr(mods = non_monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))

success_probabilities_non_monotonic <- assessDesign(
  n_patients  = Nsample,
  mods        = non_monotonic_models,
  prior_list  = uninf_prior_list,
  sd          = sd.sim,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_Bay_non_monotonic[[paste0("max_effect_", expectedEffect[i])]] <- success_probabilities_non_monotonic
  
})

results_non_monotonic_Bay <- extract_success_rates(results_list_Bay_non_monotonic, non_monotonic_scenario)

non_monotonic_Bay <- print_result_Bay_max_eff(results_non_monotonic_Bay, c(non_monotonic_scenario, "average"), expectedEffect)
  
non_monotonic_Bay$kable_result


```
### Nsample
```{r}
# Initialize list to store results
results_list_nsample_non_monotonic_Bay <- list()

non_monotonic_models <- Mods(linear=NULL, 
                             emax = emax.g,
                             sigEmax = sigEmax.g,
                             quadratic = quad.g,
                             betaMod = beta.g,
                             doses = doses.sim,
                             placEff = plc.guess, 
                             maxEff = expectedEffect_fix,
                             direction = "increasing",
                             addArgs = list(scal=8.6))
 
  #optimal contrasts
contM <- getContr(mods = non_monotonic_models, 
                  dose_levels = doses.sim, 
                  prior_list = uninf_prior_list, 
                  dose_weights = c(1,1,1,1,1))
  
# Loop over nsample values
for (i in seq_along(nsample_list)) {
  


success_probabilities_non_monotonic <- assessDesign(
  n_patients  = nsample_list[[i]],
  mods        = non_monotonic_models,
  prior_list  = uninf_prior_list,
  sd          = sd.sim,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_nsample_non_monotonic_Bay[[paste0("nsample_", nsample_list[i])]] <- success_probabilities_non_monotonic
  
}

results_non_monotonic_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_non_monotonic_Bay, non_monotonic_scenario)


non_monotonic_nsample_Bay <- print_result_Bay_nsample(results_non_monotonic_Bay_nsample, c(non_monotonic_scenario, "average"), nsample_vector)
non_monotonic_nsample_Bay$kable_result


```


## variability scenario
### Maximum effect
```{r}

# prior 
var_uninf_prior_list <- list(
                   Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"),
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 0, n = 1), sigma = sd.sim_var, param = "mn"))

results_list_Bay_var <- list()


results_list_Bay_var <- purrr::map(c(0.05,0.1,0.2,0.3,0.5), function(i) {

var_models <- Mods(linear = NULL, 
                   exponential = exp.g,
                   emax = emax.g,
                   logistic=logit.g,
                   sigEmax = sigEmax.g,
                   doses = doses_var,
                   placEff = plc.guess, 
                   maxEff = i,
                   direction = "increasing")

contM <- getContr(mods = var_models, 
                  dose_levels = doses_var, 
                  prior_list = var_uninf_prior_list, 
                  dose_weights = c(1,1,1,1))

success_probabilities_var <- assessDesign(
  n_patients  = Nsample_var,
  mods        = var_models,
  prior_list  = var_uninf_prior_list,
  sd          = sd.sim_var,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)

# Store result in list
  results_list_Bay_var[[paste0("max_effect_", expectedEffect[i])]] <- success_probabilities_var
})

results_variability_Bay <- extract_success_rates(results_list_Bay_var, variability_scenario)

variability_Bay <- print_result_Bay_max_eff(results_variability_Bay, c(variability_scenario, "average"), expectedEffect)

variability_Bay$kable_result


```
###Nsample
```{r}
results_list_nsample_Bay_var <- list()

var_models <- Mods(linear=NULL,
                   exponential = exp.g,
                   emax = emax.g,
                   logistic=logit.g,
                   sigEmax = sigEmax.g,
                   doses = doses_var,
                   placEff = plc.guess, 
                   maxEff = expectedEffect_fix,
                   direction = "increasing")

contM <- getContr(mods = var_models, 
                  dose_levels = doses_var, 
                  prior_list = var_uninf_prior_list, 
                  dose_weights = c(1,1,1,1))

# Loop over nsample values
for (i in seq_along(nsample_list_var)) {
  


success_probabilities_var <- assessDesign(
  n_patients  = nsample_list_var[[i]],
  mods        = var_models,
  prior_list  = var_uninf_prior_list,
  sd          = sd.sim_var,
  n_sim       = n_sim,
  alpha_crit_val = alpha, 
  contr = contM)


# Store result in list
  results_list_nsample_Bay_var[[paste0("nsample_", nsample_list[i])]] <- success_probabilities_var
  
}

results_variability_Bay_nsample <- extract_success_rates_nsample(results_list_nsample_Bay_var, variability_scenario)


var_nsample_Bay <-  print_result_Bay_nsample(results_variability_Bay_nsample, c(variability_scenario, "average"), as.vector(nsample_list_var))
var_nsample_Bay$kable_result


##############test purr::map



#results_list_nsample_Bay_var <- purrr::map(nsample_list_var, function(i) {

#  success_probabilities_var <- assessDesign(
#    n_patients  = i,
#    mods        = var_models,
#    prior_list  = var_uninf_prior_list,
#    sd          = sd.sim_var,
#    n_sim       = n_sim,
#    alpha_crit_val = alpha, 
#    contr = contM)

  # Return result
#   list(paste0("nsample_", i), success_probabilities_var)
  
#}) 

```


# Comparison

## maximum effect
### minimal scenario
```{r}
results_min_max_eff <- data.table(
  linear = as.vector(minimal_Bay$result_table$linear)-as.vector(results_min_MCP$Linear),
  exponential = as.vector(minimal_Bay$result_table$exponential)-as.vector(results_min_MCP$Exponential),
  emax = as.vector(minimal_Bay$result_table$emax)-as.vector(results_min_MCP$Emax),
  expectedEffect = expectedEffect
)

results_min_max_eff <- melt(results_min_max_eff, id.vars = "expectedEffect")

plot_minimal <- ggplot2::ggplot(results_min_max_eff, aes(x = expectedEffect, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green"))+
  labs(x = "assumed maximum effects", y = "power deviation")+
  ylim(c(-0.1, 0.1))+
  theme_classic()
plot_minimal
```
### monotonic scenario
```{r}
results_monotonic_max_eff <- data.table(
  linear = as.vector(monotonic_Bay$result_table$linear)-as.vector(results_monotonic_MCP$Linear),
  exponential = as.vector(monotonic_Bay$result_table$exponential)-as.vector(results_monotonic_MCP$Exponential),
  emax = as.vector(monotonic_Bay$result_table$emax)-as.vector(results_monotonic_MCP$Emax),
  logistic = as.vector(monotonic_Bay$result_table$logistic)-as.vector(results_monotonic_MCP$Logistic),
  sigemax = as.vector(monotonic_Bay$result_table$sigEmax)-as.vector(results_monotonic_MCP$sigEmax),
  expectedEffect = expectedEffect
)

results_monotonic_max_eff <- melt(results_monotonic_max_eff, id.vars = "expectedEffect")

plot_monotonic <- ggplot2::ggplot(results_monotonic_max_eff, aes(x = expectedEffect, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "assumed maximum effects", y = "power deviation")+
  ylim(c(-0.1, 0.1))+
  theme_classic()
plot_monotonic
```

### non - monotonic scenario

```{r}
results_non_monotonic_max_eff <- data.table(
  linear = as.vector(non_monotonic_Bay$result_table$linear)-as.vector(results_non_monotonic_MCP$Linear),
  emax = as.vector(non_monotonic_Bay$result_table$emax)-as.vector(results_non_monotonic_MCP$Emax),
  sigemax = as.vector(non_monotonic_Bay$result_table$sigEmax)-as.vector(results_non_monotonic_MCP$sigEmax),
  quadratic = as.vector(non_monotonic_Bay$result_table$quadratic)-as.vector(results_non_monotonic_MCP$quadratic),
  expectedEffect = expectedEffect
  )

results_non_monotonic_max_eff <- melt(results_non_monotonic_max_eff, id.vars = "expectedEffect")

plot_non_monotonic <- ggplot2::ggplot(results_non_monotonic_max_eff, aes(x = expectedEffect, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "quadratic" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "assumed maximum effects", y = "power deviation")+
  theme_classic()

plot_non_monotonic
```

### variability scenario

```{r}
results_var_max_eff <- data.table(
  linear = as.vector(variability_Bay$result_table$linear)-as.vector(results_var_MCP$Linear),
  exponential =  as.vector(variability_Bay$result_table$exponential)-as.vector(results_var_MCP$Exponential),
  emax =  as.vector(variability_Bay$result_table$emax)-as.vector(results_var_MCP$Emax),
  logistic =  as.vector(variability_Bay$result_table$logistic)-as.vector(results_var_MCP$Logistic),
  sigemax =  as.vector(variability_Bay$result_table$sigEmax)-as.vector(results_var_MCP$sigEmax),
  expectedEffect = expectedEffect
)

results_var_max_eff <- melt(results_var_max_eff, id.vars = "expectedEffect")

plot_var <- ggplot2::ggplot(results_var_max_eff, aes(x = expectedEffect, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "assumed maximum effects", y = "power deviation")+
  theme_classic()

plot_var
```
## Nsample

```{r}
nsample_vector <- as.vector(c("(40,20,20,20,40)","(30,30,30,30,30)", "(48,24,24,24,48)","(36,36,36,36,36)"))
```

### minimal scenario
```{r}

results_min_nsample <- data.table(
  linear = as.vector(minimal_nsample_Bay$result_table$linear)-as.vector(results_min_MCP_nsample$Linear),
  exponential = as.vector(minimal_nsample_Bay$result_table$exponential)-as.vector(results_min_MCP_nsample$Exponential),
  emax = as.vector(minimal_nsample_Bay$result_table$emax)-as.vector(results_min_MCP_nsample$Emax),
  nsample_vector = nsample_vector
)

results_min_nsample <- melt(results_min_nsample, id.vars = "nsample_vector")

plot_minimal_nsample <- ggplot2::ggplot(results_min_nsample, aes(x = nsample_vector, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green"))+
  labs(x = "sample sizes", y = "power deviation")+
  theme_classic()
plot_minimal_nsample

```

### monotonic scenario

```{r}
results_monotonic_nsample <- data.table(
  linear = as.vector(monotonic_nsample_Bay$result_table$linear)-as.vector(results_monotonic_MCP_nsample$Linear),
  exponential = as.vector(monotonic_nsample_Bay$result_table$exponential)-as.vector(results_monotonic_MCP_nsample$Exponential),
  emax = as.vector(monotonic_nsample_Bay$result_table$emax)-as.vector(results_monotonic_MCP_nsample$Emax),
  logistic = as.vector(monotonic_nsample_Bay$result_table$logistic)-as.vector(results_monotonic_MCP_nsample$Logistic),
  sigemax = as.vector(monotonic_nsample_Bay$result_table$sigEmax)-as.vector(results_monotonic_MCP_nsample$sigEmax),
  nsample_vector = nsample_vector
)

results_monotonic_nsample <- melt(results_monotonic_nsample, id.vars = "nsample_vector")

plot_monotonic_nsample <- ggplot2::ggplot(results_monotonic_nsample, aes(x = nsample_vector, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "sample sizes", y = "power deviation")+
  theme_classic()
plot_monotonic_nsample
```
### non-monotonic scenario

```{r}
results_non_monotonic_nsample <- data.table(
  linear = as.vector(non_monotonic_nsample_Bay$result_table$linear)-as.vector(results_non_monotonic_MCP_nsample$Linear),
  emax = as.vector(non_monotonic_nsample_Bay$result_table$emax)-as.vector(results_non_monotonic_MCP_nsample$Emax),
  sigemax = as.vector(non_monotonic_nsample_Bay$result_table$sigEmax)-as.vector(results_non_monotonic_MCP_nsample$sigEmax),
  quadratic = as.vector(non_monotonic_nsample_Bay$result_table$quadratic)-as.vector(results_non_monotonic_MCP_nsample$quadratic),
  nsample_vector = nsample_vector
  )

results_non_monotonic_nsample <- melt(results_non_monotonic_nsample, id.vars = "nsample_vector")

plot_non_monotonic_nsample <- ggplot2::ggplot(results_non_monotonic_nsample, aes(x = nsample_vector, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "quadratic" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "sample sizes", y = "power deviation")+
  theme_classic()
plot_non_monotonic_nsample
```

### variability sceanrio

```{r}
results_var_nsample <- data.table(
  linear = as.vector(var_nsample_Bay$result_table$linear)-as.vector(results_var_MCP_nsample$Linear),
  exponential =  as.vector(var_nsample_Bay$result_table$exponential)-as.vector(results_var_MCP_nsample$Exponential),
  emax =  as.vector(var_nsample_Bay$result_table$emax)-as.vector(results_var_MCP_nsample$Emax),
  logistic =  as.vector(var_nsample_Bay$result_table$logistic)-as.vector(results_var_MCP_nsample$Logistic),
  sigemax =  as.vector(var_nsample_Bay$result_table$sigEmax)-as.vector(results_var_MCP_nsample$sigEmax),
  nsample_vector = nsample_vector
)

results_var_nsample <- melt(results_var_nsample, id.vars = "nsample_vector")

plot_var_nsample <- ggplot2::ggplot(results_var_nsample, aes(x = nsample_vector, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exponential" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "sample sizes", y = "power deviation")+
  theme_classic()
plot_var_nsample
```

## different n_sim

### minimal scenario

```{r}

# Define a vector of different n_sim values
n_sim_values <- c(100, 500, 1000, 5000, 10000)

# Initialize a list to store the results
results_list_nsim_Bay <- list()

min_models <- Mods(linear=NULL,
                     exponential = exp.g,
                     emax = emax.g,
                     doses = doses.sim,
                     placEff = plc.guess,
                     maxEff = expectedEffect_fix,
                     direction = "increasing")
#optimal contrasts
contM <- getContr(mods = min_models,
                    dose_levels = doses.sim,
                    prior_list = uninf_prior_list,
                    dose_weights = c(1,1,1,1,1))


# Loop over the n_sim_values
for (i in n_sim_values) {
  # Run the simulation with the current n_sim value
  success_probabilities <- assessDesign(
    n_patients  = Nsample,
    mods        = min_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = i,
    alpha_crit_val = alpha,
    contr = contM)

  # Store the results in the list
  results_list_nsim_Bay[[as.character(i)]] <- success_probabilities
}


results_nsim_Bay <- extract_success_rates_nsim(results_list_nsim_Bay, min_scenario, n_sim_values)


```


```{r warning=FALSE}
#Warning: the line search routine failed, possibly due to insufficient numeric precision
#Are 10.000 simulations enough? MCPModPack only up to <=10000?

# Initialize a list to store the results
results_list_nsim_MCP = list(
  power_min_nsim_linear = vector(),
  power_min_nsim_exp = vector(),
  power_min_nsim_emax = vector())

# assumed dose - response model
sim_models_min_linear = list(linear = NA,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_exp = list(exponential = 4.447149,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

sim_models_min_emax = list( emax = 0.6666667,
                  max_effect = expectedEffect_fix,
                  sd = rep(sd.sim, length(doses.sim)),
                  placebo_effect = plc.guess)

# Simulation parameters
sim_parameters = list(n = Nsample,
                      doses = doses.sim,
                      dropout_rate = 0.0,
                      go_threshold = 0.1,
                      nsims = n_sim)


# Loop over the n_sim_values
for (i in n_sim_values) {
 sim_parameters$nsims <- i

   # power values for different assumed true models
  power_nsim_linear <- func_sim(min_modelsPack, sim_models_min_linear, sim_parameters)
  results_list_nsim_MCP$power_min_nsim_linear[as.character(i)] <- power_nsim_linear$sim_results$power

  power_nsim_exp <- func_sim(min_modelsPack, sim_models_min_exp, sim_parameters)
  results_list_nsim_MCP$power_min_nsim_exp[as.character(i)] <-power_nsim_exp$sim_results$power

  power_nsim_emax <- func_sim(min_modelsPack, sim_models_min_emax, sim_parameters)
  results_list_nsim_MCP$power_min_nsim_emax[as.character(i)] <- power_nsim_exp$sim_results$power

}
```




```{r}
#safe results in data.table for plot
results_nsim <- data.table(
  MCP_linear = results_list_nsim_MCP$power_min_nsim_linear,
  MCP_exp = results_list_nsim_MCP$power_min_nsim_exp,
  MCP_emax = results_list_nsim_MCP$power_min_nsim_emax,
  Bay_linear = results_nsim_Bay$Bay_linear,
  Bay_exp = results_nsim_Bay$Bay_exponential,
  Bay_emax = results_nsim_Bay$Bay_emax)

results_nsim_diff <- data.table(
  linear = results_nsim$Bay_linear - results_nsim$MCP_linear,
  exp = results_nsim$Bay_exp - results_nsim$MCP_exp,
  emax = results_nsim$Bay_emax - results_nsim$MCP_emax,
  n_sim = n_sim_values
)

results_nsim_diff <- melt(results_nsim_diff, id.vars = "n_sim")

plot_nsim <- ggplot2::ggplot(results_nsim_diff, aes(x = n_sim, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exp" = "blue", "emax" = "green"))+
  labs(x = "nsim", y = "power deviation")+
  theme_classic()
plot_nsim
```
### monotonic scenario

```{r}
# Initialize a list to store the results
 results_list_nsim_Bay_monotonic <- list()
 
monotonic_models <- Mods(linear=NULL,
                         exponential = exp.g,
                         emax = emax.g,
                         logistic=logit.g,
                         sigEmax = sigEmax.g,
                         doses = doses.sim,
                         placEff = plc.guess,
                         maxEff = expectedEffect_fix,
                         direction = "increasing")

#optimal contrasts
contM <- getContr(mods = monotonic_models,
                  dose_levels = doses.sim,
                  prior_list = uninf_prior_list,
                  dose_weights = c(1,1,1,1,1))

# Loop over the n_sim_values
for (i in n_sim_values) {
  # Run the simulation with the current n_sim value
  success_probabilities <- assessDesign(
    n_patients  = Nsample,
    mods        = monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = i,
    alpha_crit_val = alpha,
    contr = contM)

  # Store the results in the list
  results_list_nsim_Bay_monotonic[[as.character(i)]] <- success_probabilities
}


results_nsim_Bay_monotonic <- extract_success_rates_nsim(results_list_nsim_Bay_monotonic, monotonic_scenario, n_sim_values)

```
```{r warning=FALSE}
results_list_nsim_MCP_monotonic = list(
  power_monotonic_nsim_linear = vector(),
  power_monotonic_nsim_exp = vector(),
  power_monotonic_nsim_emax = vector(),
  power_monotonic_nsim_logistic = vector(),
  power_monotonic_nsim_sigemax = vector())

sim_models_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_monotonic_exp$max_effect <- expectedEffect_fix
sim_models_monotonic_logistic$max_effect <- expectedEffect_fix
sim_models_monotonic_sigemax$max_effect <- expectedEffect_fix



# Loop over the n_sim_values
for (i in n_sim_values) {
 sim_parameters$nsims <- i

   # power values for different assumed true models
  power_nsim_linear <- func_sim(monotonic_modelsPack, sim_models_monotonic_linear, sim_parameters)
  results_list_nsim_MCP_monotonic$power_monotonic_nsim_linear[as.character(i)] <- power_nsim_linear$sim_results$power

  power_nsim_exp <- func_sim(monotonic_modelsPack, sim_models_monotonic_exp, sim_parameters)
  results_list_nsim_MCP_monotonic$power_monotonic_nsim_exp[as.character(i)] <-power_nsim_exp$sim_results$power

  power_nsim_emax <- func_sim(monotonic_modelsPack, sim_models_monotonic_emax, sim_parameters)
  results_list_nsim_MCP_monotonic$power_monotonic_nsim_emax[as.character(i)] <- power_nsim_exp$sim_results$power

  power_nsim_logistic <- func_sim(monotonic_modelsPack, sim_models_monotonic_logistic, sim_parameters)
  results_list_nsim_MCP_monotonic$power_monotonic_nsim_logistic[as.character(i)] <- power_nsim_logistic$sim_results$power

  power_nsim_sigemax <- func_sim(monotonic_modelsPack, sim_models_monotonic_sigemax, sim_parameters)
  results_list_nsim_MCP_monotonic$power_monotonic_nsim_sigemax[as.character(i)] <- power_nsim_sigemax$sim_results$power


}
```

```{r}
#safe results in data.table for plot
results_nsim_monotonic <- data.table(
  MCP_linear = results_list_nsim_MCP_monotonic$power_monotonic_nsim_linear,
  MCP_exp = results_list_nsim_MCP_monotonic$power_monotonic_nsim_exp,
  MCP_emax = results_list_nsim_MCP_monotonic$power_monotonic_nsim_emax,
  MCP_logistic = results_list_nsim_MCP_monotonic$power_monotonic_nsim_logistic,
  MCP_sigemax = results_list_nsim_MCP_monotonic$power_monotonic_nsim_sigemax,
  Bay_linear = results_nsim_Bay_monotonic$Bay_linear,
  Bay_exp = results_nsim_Bay_monotonic$Bay_exponential,
  Bay_emax = results_nsim_Bay_monotonic$Bay_emax,
  Bay_logistic = results_nsim_Bay_monotonic$Bay_logistic,
  Bay_sigemax = results_nsim_Bay_monotonic$Bay_sigEmax)

results_nsim_diff_monotonic <- data.table(
  linear = results_nsim_monotonic$Bay_linear - results_nsim_monotonic$MCP_linear,
  exp = results_nsim_monotonic$Bay_exp - results_nsim_monotonic$MCP_exp,
  emax = results_nsim_monotonic$Bay_emax - results_nsim_monotonic$MCP_emax,
  logistic = results_nsim_monotonic$Bay_logistic - results_nsim_monotonic$MCP_logistic,
  sigemax = results_nsim_monotonic$Bay_sigemax - results_nsim_monotonic$MCP_sigemax,
  n_sim = n_sim_values
)

results_nsim_diff_monotonic <- melt(results_nsim_diff_monotonic, id.vars = "n_sim")

plot_nsim_monotonic <- ggplot2::ggplot(results_nsim_diff_monotonic, aes(x = n_sim, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "exp" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "nsim", y = "power deviation")+
  theme_classic()
plot_nsim_monotonic
```
### non - monotonic scenario

```{r}
# Initialize list to store results
results_list_nsim_Bay_non_monotonic <- list()

non_monotonic_models <- Mods(linear=NULL,
                             emax = emax.g,
                             sigEmax = sigEmax.g,
                             quadratic = quad.g,
                             betaMod = beta.g,
                             doses = doses.sim,
                             placEff = plc.guess,
                             maxEff = expectedEffect_fix,
                             direction = "increasing",
                             addArgs = list(scal=8.6))

  #optimal contrasts
contM <- getContr(mods = non_monotonic_models,
                  dose_levels = doses.sim,
                  prior_list = uninf_prior_list,
                  dose_weights = c(1,1,1,1,1))

# Loop over the n_sim_values
for (i in n_sim_values) {
  # Run the simulation with the current n_sim value
  success_probabilities <- assessDesign(
    n_patients  = Nsample,
    mods        = non_monotonic_models,
    prior_list  = uninf_prior_list,
    sd          = sd.sim,
    n_sim       = i,
    alpha_crit_val = alpha,
    contr = contM)

  # Store the results in the list
  results_list_nsim_Bay_non_monotonic[[as.character(i)]] <- success_probabilities
}


results_nsim_Bay_non_monotonic <- extract_success_rates_nsim(results_list_nsim_Bay_non_monotonic, non_monotonic_scenario, n_sim_values)
```

```{r, warning=FALSE}
results_list_nsim_MCP_non_monotonic = list(
  power_non_monotonic_nsim_linear = vector(),
  power_non_monotonic_nsim_emax = vector(),
  power_non_monotonic_nsim_sigemax= vector(),
  power_non_monotonic_nsim_quadratic = vector(),
  power_non_monotonic_nsim_beta = vector())

sim_models_non_monotonic_linear$max_effect <- expectedEffect_fix
sim_models_non_monotonic_emax$max_effect <- expectedEffect_fix
sim_models_non_monotonic_sigemax$max_effect <- expectedEffect_fix
sim_models_non_monotonic_quadratic$max_effect <- expectedEffect_fix
sim_models_non_monotonic_beta$max_effect <- expectedEffect_fix


# Loop over the n_sim_values
for (i in n_sim_values) {
 sim_parameters$nsims <- i

   # power values for different assumed true models
  power_nsim_linear <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_linear, sim_parameters)
  results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_linear[as.character(i)] <- power_nsim_linear$sim_results$power

  power_nsim_emax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_emax, sim_parameters)
  results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_emax[as.character(i)] <-power_nsim_emax$sim_results$power

  power_nsim_sigemax <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_sigemax, sim_parameters)
  results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_sigemax[as.character(i)] <- power_nsim_sigemax$sim_results$power

  power_nsim_quadratic <- func_sim(non_monotonic_modelsPack, sim_models_non_monotonic_quadratic, sim_parameters)
  results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_quadratic[as.character(i)] <- power_nsim_quadratic$sim_results$power

  #power_nsim_beta <- func_sim(sim_models_non_monotonic_beta, sim_parameters)
  #results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_beta[as.character(i)] <- power_nsim_beta$sim_results$power



}
```

```{r}
#safe results in data.table for plot
results_nsim_non_monotonic <- data.table(
  MCP_linear = results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_linear,
  MCP_emax = results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_emax,
  MCP_sigemax = results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_sigemax,
  MCP_quadratic = results_list_nsim_MCP_non_monotonic$power_non_monotonic_nsim_sigemax,
  Bay_linear = results_nsim_Bay_non_monotonic$Bay_linear,
  Bay_emax = results_nsim_Bay_monotonic$Bay_emax,
  Bay_sigemax = results_nsim_Bay_non_monotonic$Bay_sigEmax,
  Bay_quadratic = results_nsim_Bay_non_monotonic$Bay_quadratic)

results_nsim_diff_non_monotonic <- data.table(
  linear = results_nsim_non_monotonic$Bay_linear - results_nsim_non_monotonic$MCP_linear,
  emax = results_nsim_non_monotonic$Bay_emax - results_nsim_non_monotonic$MCP_emax,
  sigemax =results_nsim_non_monotonic$Bay_sigemax - results_nsim_non_monotonic$MCP_sigemax,
  quadratic = results_nsim_non_monotonic$Bay_quadratic - results_nsim_non_monotonic$MCP_quadratic,
  n_sim = n_sim_values
)


results_nsim_diff_non_monotonic <- melt(results_nsim_diff_non_monotonic, id.vars = "n_sim")

plot_nsim_non_monotonic <- ggplot2::ggplot(results_nsim_diff_non_monotonic, aes(x = n_sim, y = value, color = variable, group = variable))+
  geom_point()+
  geom_line() +
  geom_hline(aes(yintercept = 0), linetype = 2)+
  scale_color_manual(name = "assumed true model", values = c("linear" = "red", "quadratic" = "blue", "emax" = "green", "logistic" = "orange", "sigemax" = "purple"))+
  labs(x = "nsim", y = "power deviation")+
  theme_classic()
plot_nsim_non_monotonic

```
### variability scenario


```{r}

# Initialize list to store results
# results_list_nsim_Bay_var <- list()
# 
# var_models <- Mods(linear=NULL,
#                    exponential = exp.g,
#                    emax = emax.g,
#                    logistic=logit.g,
#                    sigEmax = sigEmax.g,
#                    doses = doses_var,
#                    placEff = plc.guess,
#                    maxEff = expectedEffect_fix,
#                    direction = "increasing")
# 
# contM <- getContr(mods = var_models,
#                   dose_levels = doses_var,
#                   prior_list = var_uninf_prior_list,
#                   dose_weights = c(1,1,1,1))
# 
# # Loop over the n_sim_values
# for (i in n_sim_values) {
#   # Run the simulation with the current n_sim value
#   success_probabilities <- assessDesign(
#     n_patients  = Nsample_var,
#     mods        = var_models,
#     prior_list  = uninf_prior_list,
#     sd          = sd.sim_var,
#     n_sim       = i,
#     alpha_crit_val = alpha,
#     contr = contM)
# 
#   # Store the results in the list
#   results_list_nsim_Bay_var[[as.character(i)]] <- success_probabilities
# }
# 
# 
# results_nsim_Bay_var <- extract_success_rates_nsim(results_list_nsim_Bay_var, variability_scenario, n_sim_values)
```

```{r, warning=FALSE}
results_list_nsim_MCP_var = list(
  power_var_nsim_linear = vector(),
  power_var_nsim_exp = vector(),
  power_var_nsim_emax= vector(),
  power_var_nsim_sigemax = vector(),
  power_var_nsim_logistic = vector())

# assume maximum effect = 0.2
sim_models_var_linear$max_effect <- expectedEffect_fix
sim_models_var_exp$max_effect <- expectedEffect_fix
sim_models_var_emax$max_effect <- expectedEffect_fix
sim_models_var_sigemax$max_effect <- expectedEffect_fix
sim_models_var_logistic$max_effect <- expectedEffect_fix



# Loop over the n_sim_values
for (i in n_sim_values) {
 sim_parameters_var$nsims <- i
  
   # power values for different assumed true models
  power_nsim_linear <- func_sim(var_modelsPack, sim_models_var_linear, sim_parameters_var)
  results_list_nsim_MCP_var$power_var_nsim_linear[as.character(i)] <- power_nsim_linear$sim_results$power
  
  power_nsim_exp <- func_sim(var_modelsPack, sim_models_var_exp, sim_parameters_var)
  results_list_nsim_MCP_var$power_var_nsim_exp[as.character(i)] <- power_nsim_exp$sim_results$power
  
  power_nsim_emax <- func_sim(var_modelsPack, sim_models_var_emax, sim_parameters_var)
  results_list_nsim_MCP_var$power_var_nsim_emax[as.character(i)] <- power_nsim_emax$sim_results$power
  
  power_nsim_sigemax <- func_sim(var_modelsPack, sim_models_var_sigemax, sim_parameters_var)
  results_list_nsim_MCP_var$power_var_nsim_sigemax[as.character(i)] <- power_nsim_sigemax$sim_results$power
  
  power_nsim_logistic <- func_sim(var_modelsPack, sim_models_var_logistic, sim_parameters_var)
  results_list_nsim_MCP_var$power_var_nsim_logistic[as.character(i)] <- power_nsim_logistic$sim_results$power
  
  
  
}
```

```{r}
# results_nsim_var <- data.table(
#   MCP_linear = results_list_nsim_MCP_var$power_var_nsim_linear,
#   MCP_exp = results_list_nsim_MCP_var$power_var_nsim_exp,
#   MCP_emax = results_list_nsim_MCP_var$power_var_nsim_emax,
#   MCP_sigemax = results_list_nsim_MCP_var$power_var_nsim_sigemax,
#   MCP_logistic = results_list_nsim_MCP_var$power_var_nsim_logistic,
#   Bay_linear = results_nsim_Bay_var$Bay_linear
# )
```



```{r}
save(results_list_nsim_Bay, results_nsim_Bay, results_list_nsim_MCP, results_nsim_Bay_monotonic, results_nsim_Bay_non_monotonic, results_min_MCP, results_monotonic_MCP, results_non_monotonic_MCP, results_var_MCP, results_min_MCP_nsample, results_monotonic_MCP_nsample, results_non_monotonic_MCP_nsample, results_var_MCP_nsample, results_min_Bay, results_min_Bay_nsample, results_monotonic_Bay, results_monotonic_Bay_nsample, results_non_monotonic_Bay, results_non_monotonic_Bay_nsample, results_variability_Bay, results_variability_Bay_nsample,
     file = "n_sim_data.RData")
```
